<!DOCTYPE html>
<html lang="en-us">
  <head>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Prehľadávanie stromu do hĺbky je ďalší klasický algoritmus, ktorý sa nám v praxi môže hodiť. Ukážeme si ho na príklade traverzovania súborového systému, kde chceme na každom súbore či adresári vykonať nejakú operáciu.">
    <title>Prehľadávanie do hĺbky v jazyku Java | robonovotny</title>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.3/styles/dracula.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.3/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.3/languages/go.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="https://novotnyr.github.io/asciidoctor.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="https://novotnyr.github.io/">~/robonovotny</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">Prehľadávanie do hĺbky v jazyku Java</span></h1>

<h2 class="date">2008/05/07</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <h1 id="úvod">Úvod</h1>
<p>V predošlom článku sme spomínali algoritmus prehľadávania do šírky, ktorý prechádzal strom ,,po vrstvách&quot;. Okrem neho jestvuje ešte analogický algoritmus prehľadávania do hĺbky. Jeho základnou ideou je preskúmavanie ciest vedúcich k čo najhlbšiemu potomkovi daného uzla.</p>
<p>Pekným príkladom prehľadávania do hĺbky je traverzovanie súborového systému. Ak chceme prejsť všetky súbory v danom adresári a jeho podadresároch (a v podadresároch jeho podadresárov), takéto prehľadávanie sa nám veľmi hodí.</p>
<p>Zjednodušený súborový systém môže vyzerať nasledovne:</p>
<p><img src="tree.png" alt=""></p>
<p>Výpis na konzolu by znamenal, že chceme vypísať niečo takéto:</p>
<pre tabindex="0"><code>C:
MP3
ABBA
Elán
Windows
System32
temp
Data
spam
</code></pre><h1 id="dátové-štruktúry">Dátové štruktúry</h1>
<p>V tomto prípade nebudeme definovať žiadnu špeciálnu triedu pre uzol, ale budeme pracovať rovno s objektami <code>java.io.File</code>. Tie totiž poskytujú možnosť vrátiť svoje deti (teda súbory a podadresáre), čo presne zodpovedá stromovej štruktúre.</p>
<p>Príklad použitia je nasledovný:</p>
<pre tabindex="0"><code>File fileC = new File(&#34;C:&#34;);
// vypíše súbory a adresáre v C:
File[] children = fileC.listFiles();
</code></pre><h1 id="algoritmy">Algoritmy</h1>
<p>Na vyriešenie tohto problému môžeme použiť dva varianty algoritmu: rekurzívnu verziu alebo klasickú verziu, v ktorej použijeme zásobník.</p>
<h2 id="rekurzívna-verzia">Rekurzívna verzia</h2>
<p>Rekurzívna verzia algoritmu je založená na jednoduchom pozorovaní: na prezretie potomkov ľubovoľného uzla potrebujeme prejsť každé dieťa a prezrieť jeho potomkov. Každého potomka prezrieme tak, že vezmeme jeho priame deti a prezrieme ich atď atď. Takto sa vnárame až dovtedy, kým nedôjdeme na ,,spodok&quot; stromu, teda k uzlom, ktoré už nemajú deti.</p>
<p><code>prejdi(U)</code>:</p>
<ol>
<li>Vezmi uzol <em>U</em> a spracuj ho</li>
<li>Ak uzol nemá deti, skonči.</li>
<li>Inak na každom dieťati <em>D</em> zavolaj (rekurzívne) metódu <code>prejdi(D)</code></li>
</ol>
<p>Ukážme si to na príklade nášho stromu:</p>
<ul>
<li>Vezmime teda uzol <code>C:</code>. Tento uzol spracujeme a postupne prejdeme jeho deti: <code>MP3</code>, <code>Windows</code> a <code>Data</code>.
<ul>
<li>Prvým dieťaťom je <code>MP3</code>. Ten spracujeme a vezmeme jeho deti: <code>ABBA</code> a <code>Elán</code>.
<ul>
<li>Na rade je <code>ABBA</code>. Tá už nemá deti, čiže ju len vypíšeme.</li>
<li>Ďalším kandidátom je <code>Elán</code>. Ten rovnako nemá deti a vypisujeme ho.</li>
</ul>
</li>
<li>Ďalším čakajúcim je <code>Windows</code>. Jeho deti sú <code>system32</code> a <code>temp</code>.
<ul>
<li>Uzol <code>system32</code> je bezdetný, čiže ho len vypíšeme.</li>
<li>Rovnakým prípadom je <code>temp</code>, ktorý tiež len vypíšeme.</li>
</ul>
</li>
<li>Tretím dieťaťom <code>C:</code> je uzol <code>Data</code> s jediným dieťaťom.
<ul>
<li><code>spam</code> vypíšeme a končíme, keďže sa už nemáme kam ,,vynoriť&quot; - všetky uzly sú spracované.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Rekurzívna verzia v Jave je potom priamym prepisom idey:</p>
<pre tabindex="0"><code>public static void traverse(File file) {
    // spracujeme súbor
    System.out.println(file);
    if(file.isDirectory()) {
        // prejdeme deti a spracujeme ich
        for (File child : file.listFiles()) {
            traverse(child);
        }
    }
}
</code></pre><p>Jediným vylepšením je overenie toho, či uzol má nejaké deti. Keďže v súborovom systéme majú deti len adresáre, do úvahy pri získavaní detí budeme brať len tie.</p>
<p>Pri návrhu rekurzívnych algoritmov je treba dať dôraz na to, aby sa rekurzia zastavila: teda aby sa volania metód, ktorá volajú samú seba „neodtrhli z reťaze“ a nevydali sa na nekonečný beh. Naša rekurzia je však korektná a zastaví sa ak narazíme na spodok stromu — teda buď na súbory (tie potomkov nemajú) alebo na prázdne adresáre. To je zahrnuté v podmienke, že či súbor je adresárom (<code>isDirectory()</code>).</p>
<h2 id="nerekurzívna-verzia">Nerekurzívna verzia</h2>
<p>Ak vás rekurzia straší, možno vám pomôže nerekurzívny variant. Spomeňme si na príklad prehľadávania do šírky. V ňom sme zobrali daný uzol, všetkých jeho potomkov zaradili do fronty a následne odbavovali ďalšie uzly čakajúce vo fronte. Prehľadávanie do hĺbky môžeme postaviť analogickým spôsobom, ibaže namiesto fronty (<em>queue</em>) použijeme <strong>zásobník</strong> (<strong>stack</strong>).</p>
<p>Zásobník možno vnímať ako obyčajný zoznam prvkov, kde pridávanie a odoberanie prvkov do zoznamu funguje tzv. „LIFO“ spôsobom — „last-in first-out“, čiže „posledný dnu-prvý von“. Predstaviť si ho môžeme ako štós tanierov, kde tanier možno položiť buď na vrchol kopy alebo ho z vrchu kopy odobrať. (Odoberať tanier z prostriedka nie je možné, lebo by sa taniere mohli rozbiť.) Typický zásobník má tieto operácie:</p>
<ul>
<li><code>boolean empty()</code> — zistí, či zásobník je prázdny</li>
<li><code>pop()</code> — odstráni objekt z vrchu zásobníka a vráti ho.</li>
<li><code>push(Object item)</code> — vloží objekt na vrchol zásobníka.</li>
</ul>
<p>Podobne ako v prípade prehľadávania do šírky budeme prechádzať strom po jednotlivých uzloch. Pre každý uzol však môžeme vybaviť jeho súrodencov až vtedy, čo sú vybavení všetci jeho potomkovia (priami i nepriami). Potomkov uzla budeme ukladať na zásobník, z ktorého budeme zároveň vyberať uzly súce na vybavenie. Algoritmus sa skončí vo chvíli, keď je zásobník prázdny, teda že už nie je čo spracovávať.</p>
<h3 id="príklad-algoritmu">Príklad algoritmu</h3>
<p>Vezmime teda uzol <code>C:</code>. Tento uzol spracujeme a jeho deti <code>MP3</code>, <code>Windows</code> a <code>Data</code> vkladajme postupne na vrchol zásobníka. Pre poriadok budeme deti prechádzať v prevrátenom poradí (aby sa na vrchol zásobníka ukladali tie uzly, ktoré budeme spracovávať ako prvé).</p>
<pre tabindex="0"><code>+-----------------------
| Data | Windows | MP3
+-----------------------
</code></pre><p>Ďalej vezmeme prvok z vrcholu zásobníka, <code>MP3</code>, vybavíme ho (vypíšeme na konzolu) a všetky jeho deti vložíme na vrchol zásobníka.</p>
<pre tabindex="0"><code>+------------------------------
| Data | Windows | Elán | ABBA
+------------------------------
</code></pre><p>Z vrchola zásobníka vezmeme <code>Abbu</code>. Tá už nemá deti, čiže ju len spracujeme a pokračujeme ďalej.</p>
<pre tabindex="0"><code>+-----------------------
| Data | Windows | Elán
+-----------------------
</code></pre><p>Teraz vezmeme z vrchola zásobníka <code>Elán</code>. Ten tiež rovnako nemá deti, čiže ho spracujeme a pokračujeme ďalej.</p>
<pre tabindex="0"><code>+----------------
| Data | Windows 
+----------------
</code></pre><p>Na vrchole zásobníka je <code>Windows</code>, ktorý má dvoch potomkov (<code>system32</code> a <code>temp</code>). Hodíme ich postupne na vrchol zásobníka.</p>
<pre tabindex="0"><code>+------------------------
| Data | temp | system32
+------------------------ 
</code></pre><p>Oba uzly, <code>system32</code> aj ``temp` sú bezdetné, teda ich len spracujeme.</p>
<pre tabindex="0"><code>+------
| Data 
+------
</code></pre><p>Na rade je <code>Data</code> s jediným potomkom, <code>spam</code>, ktorý hodíme do (zhodou okolností prázdneho) zásobníka.</p>
<pre tabindex="0"><code>+------
| spam
+------
</code></pre><p>Spracovaním uzla <code>spam</code> končíme algoritmus, keďže zásobník je už prázdny.</p>
<h3 id="idea-algoritmu">Idea algoritmu</h3>
<p>Idea algoritmu je potom nasledovná:</p>
<ol>
<li>vložme na vrchol zásobníka koreň stromu</li>
<li>ak je zásobník prázdny, končíme</li>
<li>inak vezmime z vrcholu zásobníka uzol a spracuj ho.</li>
<li>vezmime jeho deti a dajme ho na vrchol zásobníka (v obrátenom poradí).</li>
<li>pokračujme krokom 2.</li>
</ol>
<h3 id="zásobník-javautilstack">Zásobník <code>java.util.Stack</code></h3>
<p>Zásobník je v Jave k dispozícii v podobe triedy <code>java.util.Stack</code>. Najdôležitejšie metódy boli zmienené vyššie.</p>
<h3 id="algoritmus-v-jave-s-použitím-zásobníka">Algoritmus v Jave s použitím zásobníka</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// vytvoríme zásobník
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stack<span style="color:#f92672">&lt;</span>File<span style="color:#f92672">&gt;</span> zásobník <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>File<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// pridáme koreň do fronty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>zásobník<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//pokiaľ fronta nie je prázdna
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span><span style="color:#f92672">(!</span>zásobník<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// vyberme uzol z vrcholu zásobníka
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    File file <span style="color:#f92672">=</span> zásobník<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// vybavme ho
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// potomkov zaradíme do fronty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>file<span style="color:#f92672">.</span><span style="color:#a6e22e">isDirectory</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        File<span style="color:#f92672">[]</span> children <span style="color:#f92672">=</span> file<span style="color:#f92672">.</span><span style="color:#a6e22e">listFiles</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// hádžeme na vrchol zásobníka v opačnom poradí
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> children<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          	zásobník<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>children<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>       
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h1 id="zabudovaný-algoritmus-v-jave">Zabudovaný algoritmus v Jave</h1>
<p>Trieda <code>javax.swing.tree.DefaultMutableTreeNode</code> má medzi svojimi metódami tiež prehľadávanie do hĺbky. Na koreňovom uzle stačí zavolať <code>depthFirstEnumeration()</code>, ktorá vráti enumeráciu uzlov.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Enumeration<span style="color:#f92672">&lt;</span>DefaultMutableTreeNode<span style="color:#f92672">&gt;</span> bfsEnum <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">depthFirstEnumeration</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>bfsEnum<span style="color:#f92672">.</span><span style="color:#a6e22e">hasMoreElements</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	DefaultMutableTreeNode treeNode  <span style="color:#f92672">=</span> bfsEnum<span style="color:#f92672">.</span><span style="color:#a6e22e">nextElement</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>  	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>treeNode<span style="color:#f92672">.</span><span style="color:#a6e22e">getUserObject</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div>
    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
    </footer>
  </body>
</html>

