<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vstupno-výstupné metódy v jazyku Java | robonovotny</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body);
        });
    </script>

<header>

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://novotnyr.github.io/">/home/robonovotny</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">Vstupno-výstupné metódy v jazyku Java</span></h1>

<h2 class="date">2007/01/12</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>



<main>


<h1 id="úvod">Úvod</h1>

<p>Programovací jazyk, ktorý by neponúkal dostatočný repertoár prostriedkov na zabezpečenie vstupu a výstupu (napr. načítavanie z klávesnice, čítanie a zápis do súborov) by bol asi veľmi rýchlo odsúdený na neúspech. Veď čo už s takým programom, s ktorým nemôžete interagovať.</p>

<p>Java poskytuje tento repertoár v plnej miere. Na rozdiel od klasických procedurálnych jazykov sú prostriedky na zabezpečenie vstupu a výstupu reprezentované pomocou viacerých tried a ich metód (združených hlavne v balíčku <code>java.io</code>). Výhodou je možnosť vytvárať mnohoraké kombinácie prístupov, ktorými je možné pokryť značné množstvo prípadov použitia (chcete načítavať komprimované dáta z Internetu?). Nevýhodou sa však môže zdať relatívna komplikovanosť niektorých postupov - tam, kde Cčkar napíše <code>scanf()</code>, sa musí začiatočník v Jave vysomáriť z toho, ktoré objekty je nutné vytvoriť a čo zavolať na dosiahnutie cieľa.</p>

<p>Triedy v balíčku <code>java.io</code> však majú logické usporiadanie a po pochopení niektorých základných myšlienkových pochodov je práca s nimi bezproblematická.</p>

<h1 id="súbory">Súbory</h1>

<p>Práca so súbormi je veľmi častá (príklady si ukážeme nižšíe). Pojmu súbor (i adresár) zodpovedá trieda <code>java.io.File</code>. Pomocou takéhoto objektu môžeme testovať existenciu súboru, či získavať zoznam podadresárov (resp. súborov), vytvárať nové súbory a pod. alebo zisťovať absolútne a relatívne cesety. Samotné načítavanie dát zo súboru však rieši iná trieda, o ktorej sa zmienime hneď.</p>

<p>Nasledovný príklad vypíše mená všetkých adresárov v danom adresári.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">File <span style="color:#5ed;font-weight:bold">file</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> File(<span style="background-color:#e0e0ff">&#34;D:\\Projects&#34;</span>);
<span style="color:#289;font-weight:bold">if</span>(file.<span style="color:#007">exists</span>()) {
  File[] <span style="color:#5ed;font-weight:bold">childFiles</span> <span style="color:#333">=</span> file.<span style="color:#007">listFiles</span>();
  <span style="color:#289;font-weight:bold">for</span> (File <span style="color:#5ed;font-weight:bold">childFile</span><span style="color:#333">:</span> childFiles) {
    <span style="color:#289;font-weight:bold">if</span>(childFile.<span style="color:#007">isDirectory</span>()) {
      System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(childFile.<span style="color:#007">getName</span>());
    }
  }
}</code></pre></div>
<p>Metódou <code>exists()</code> overíme existenciu súboru či adresára. Metóda <code>listFiles()</code> vráti zoznam súborov a adresárov v danom adresári, z ktorých vypíšeme len mená (metóda <code>getName()</code>) vráti len meno súboru bez adresárov).</p>

<p>Všimnime si, že na Windowse musíme zdvojiť spätné lomky v ceste k adresáru. Alternatívne môžeme používať aj obyčajné lomky (teda <code>/</code>), Java si s tým poradí a to aj na Windowse.</p>

<h1 id="vstupné-prúdy">Vstupné prúdy</h1>

<p>Výlet po triedach balíčka <code>java.io</code> začneme vstupnými prúdmi. <strong>Vstupný prúd</strong> je objekt, ktorý dokáže <em>odniekiaľ</em> načítavať bajty. Zdrojom bajtov môže byť naozaj hocičo, napr. súbor, rúra či internetové pripojenie.</p>

<p>Vstupnému prúdu zodpovedá trieda <code>java.io.InputStream</code>. Táto trieda je abstraktná (čiže si nevyrobíte novú inštanciu). Jej jednotliví dedičia reprezentujú konkrétne zdroje bajtov. Pri pohľade na dokumentáciu sa zamerajme na dve najdôležitejšie metódy:</p>

<ul>
<li><code>int read()</code> načíta jeden bajt. Bajt je reprezentovaný <code>int</code>om ako číslom medzi 0..255. Ak nastane koniec súboru, vráti sa -1.</li>
<li><code>int read(byte[] buf)</code> naplní pole bajtmi načítanými zo zdroja. Vráti počet skutočne načítaných bajtov. Treba poznamenať, že vstupno-výstupné operácie sú blokujúce – teda vykonávanie príslušného vlákna sa pozastaví, kým zo zdroja „neprilezú&rdquo; všetky požadované bajty. (To sa zrejme v praxi ukáže v prípade načítavania bajtov zo siete.)</li>
<li><code>close()</code> uzatvorí vstupný prúd. V prípade súborov sa oznámi operačnému systému, že súbor je možné uzavrieť, v prípade sieťového spojenia je ho možné ukončiť a pod. Platí zásada, že po skončení práce so vstupným prúdom sme povinní ho uzavrieť.</li>
</ul>

<p>Všetky metódy hádžu výnimku <code>java.io.IOException</code>. Vstupný prúd je nutné uzavrieť vždy a to i v prípade, že nastane výnimka. Vhodným miestom je teda <code>finally</code> blok.</p>

<h2 id="súborový-vstupný-prúd">Súborový vstupný prúd</h2>

<p>Jedným z konkrétnych vstupných prúdov je súborový vstupný prúd, <code>java.io.FileInputStream</code>, ktorý umožňuje načítavať bajty zo súboru. Príklad použitia, kde zo súboru načítame prvé štyri bajty je nasledovný:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">InputStream <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  in <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileInputStream(
    <span style="background-color:#e0e0ff">&#34;d:\\Projects\\io\\bin\\InputStreamTest.class&#34;</span>);
  <span style="color:#289;font-weight:bold">for</span> (<span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">i</span> <span style="color:#333">=</span> 0; i <span style="color:#333">&lt;</span> 4; i<span style="color:#333">++</span>) {
    <span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">aByte</span> <span style="color:#333">=</span> in.<span style="color:#007">read</span>();
    System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(Integer.<span style="color:#007">toHexString</span>(aByte));
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> { 
    in.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">/*
</span><span style="color:#666;font-style:italic">     ak nastala chyba pri zatváraní súboru, už je to jedno, 
</span><span style="color:#666;font-style:italic">     ignorujeme ju
</span><span style="color:#666;font-style:italic">    */</span>
  }
}</code></pre></div>
<p>Objekt <code>FileInputStream</code> bol vytvorený nad daným súborom, pričom sme v konštruktore špecifikovali rovno cestu. Jednotlivé bajty sú pred výpisom na konzolu konvertované na šestnástkový zápis – mali by sme vidieť text <code>CAFEBABE</code>, čo je hlavička <code>.class</code> súborov v Jave.</p>

<p>Alternatívne je možné vytvoriť <code>FileInputStream</code> nad objektom typu <code>File</code>, čiže spôsobom:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">File <span style="color:#5ed;font-weight:bold">f</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> File(<span style="background-color:#e0e0ff">&#34;d:\\Projects\\io\\bin\\InputStreamTest.class&#34;</span>);
InputStream <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileInputStream(f);</code></pre></div>
<h2 id="vstupný-prúd-pre-url-adresy">Vstupný prúd pre URL adresy</h2>

<p>Ďalším príkladom vstupného prúdu sú bajty prichádzajúce zo zdroja reprezentovaného URL adresou, typicky z internetovej stránky. Na rozdiel od súborového vstupného prúdu, kde používame <code>FileInputStream</code> však nemôžeme použiť <code>URLInputStream</code> (taká trieda totiž nejestvuje). Musíme vytvoriť objekt pre URL adresu, teda inštanciu triedy <code>java.net.URL</code>, a z neho získať <code>InputStream</code>.</p>

<p>To je možno nekonzistentné s prácou so súbormi (možno by sme očakávali, že aj súbor <code>File</code> by nám dokázal poskytnúť <code>InputStream</code>, ale nie je to tak), musíme sa však s tým zmieriť.</p>

<p>Príklad získania vstupného prúdu z URL adresy je uvedený nižšie.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">InputStream <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  URL <span style="color:#5ed;font-weight:bold">url</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> URL(<span style="background-color:#e0e0ff">&#34;http://www.google.com&#34;</span>);
  in <span style="color:#333">=</span> url.<span style="color:#007">openStream</span>();
  <span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">i</span> <span style="color:#333">=</span> 0;
  <span style="color:#289;font-weight:bold">while</span>((i <span style="color:#333">=</span> in.<span style="color:#007">read</span>()) <span style="color:#333">!=</span> <span style="color:#333">-</span>1) {
    System.<span style="color:#007">out</span>.<span style="color:#007">print</span>((<span style="color:#66f;font-weight:bold">char</span>) i);
  }
} <span style="color:#289;font-weight:bold">catch</span> (MalformedURLException <span style="color:#5ed;font-weight:bold">e</span>) {
  System.<span style="color:#007">err</span>.<span style="color:#007">println</span>(<span style="background-color:#e0e0ff">&#34;Neplatná adresa.&#34;</span>);
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  System.<span style="color:#007">err</span>.<span style="color:#007">println</span>(<span style="background-color:#e0e0ff">&#34;Vstupno-výstupná chyba.&#34;</span>);
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> {
    in.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">// do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Trieda <code>URL</code> nie je obmedzená len na internetové adresy. Pomocou nej možno získavať vstupné prúdy z obyčajných súborov, JAR archívov a pod. Ak vytvoríme objekt URL nasledovne, získame tým vstupný prúd nad obyčajným súborom.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">URL <span style="color:#5ed;font-weight:bold">url</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> URL(<span style="background-color:#e0e0ff">&#34;file:///c:/autoexec.bat&#34;</span>);</code></pre></div>
<p>Všimnime si, že konštruktor <code>URL</code> hádže výnimku <code>java.net.MalformedUrlException</code> a to v prípade, že adresa používa nepodporovaný protokol. Ak vytvoríme adresu <code>http://ždiebik.sk</code>, tak výnimka nenastane (napriek tomu, že taká adresa určite nejestvuje). Na druhej strane, vytvorenie adresy nad <a href="http://magnet-uri.sourceforge.net/">Magnet linkom</a> by výnimku vyvolalo.</p>

<h1 id="výstupné-prúdy">Výstupné prúdy</h1>

<p>Ukázali sme si spôsob, ktorým je možné načítavať bajty. Čo však so zápisom? Existuje niečo ako <code>OutputStream</code>? Náhľad do dokumentácie ukáže, že áno. Ku vstupným prúdom existujú ich protipóly – výstupné prúdy, ktoré dokážu zapísať „niekam&rdquo; jeden alebo viac bajtov.</p>

<p>Trieda <code>java.io.OutputStream</code> má opäť niekoľko najdôležitejších metód:</p>

<ul>
<li><code>void write(int b)</code> zapíše jeden bajt.</li>
<li><code>void write(byte[] b)</code> zapíše pole bajtov.</li>
<li><code>void flush()</code> zapíše dáta z medzipamäte na príslušný výstup.</li>
<li><code>void close()</code> uzatvorí výstupný prúd. Podobne ako v prípade vstupných prúdov je takpovediac povinnosťou po skončení práce uzavrieť výstupný prúd. Ak sa tak nestane, môžu sa dokonca stratiť dáta (napr. sa nemusia zapísať dáta v medzipamäti). Ak zabudneme zavrieť výstupný prúd nad súborom vo Windowse, iné procesy nebudú môcť do tohto súboru zapisovať, čo môže spôsobiť značné problémy.</li>
</ul>

<p>Všetky metódy tiež hádžu výnimku <code>java.io.IOException</code>.</p>

<h2 id="súborový-výstupný-prúd">Súborový výstupný prúd</h2>

<p><code>OutputStream</code> je opäť abstraktná trieda a až jej podtriedy špecifikujú konkrétny cieľ, do ktorého sa budú zapisovať dáta. K dispozícii je napr. súborový vstupný prúd, <code>java.io.FileOutputStream</code> demonštrovaný nižšie. Do príslušného súboru zapíšeme štyri bajty:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">OutputStream <span style="color:#5ed;font-weight:bold">out</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  out <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileOutputStream(
    <span style="background-color:#e0e0ff">&#34;d:\\Projects\\paz-pisomka\\InputStreamTest.bin&#34;</span>);
  <span style="color:#289;font-weight:bold">for</span> (<span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">i</span> <span style="color:#333">=</span> 0; i <span style="color:#333">&lt;</span> 4; i<span style="color:#333">++</span>) {
    <span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">aByte</span> <span style="color:#333">=</span> 65 <span style="color:#333">+</span> i;
    out.<span style="color:#007">write</span>(aByte);
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> { 
    out.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">// do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Namiesto cyklu by sme mohli použiť metódu zapisujúcu pole bajtov:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">out.<span style="color:#007">write</span>(<span style="color:#289;font-weight:bold">new</span> <span style="color:#66f;font-weight:bold">byte</span>[] {65, 66, 67, 68});</code></pre></div>
<p><code>FileOutputStream</code> štandardne súbory prepisuje. Môžeme však použiť alternatívny konštruktor:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">OutputStream <span style="color:#5ed;font-weight:bold">out</span> 
  <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileOutputStream(<span style="background-color:#e0e0ff">&#34;d:\\Projects\\io\\InputStreamTest.bin&#34;</span>, 
                         <span style="color:#289;font-weight:bold">true</span>);</code></pre></div>
<p>kde <code>true</code> v druhom parametri nastaví pripájanie dát k existujúcim (<em>append</em> mód).</p>

<h1 id="načítavanie-reťazcov-pomocou-readerov">Načítavanie reťazcov pomocou <em>readerov</em></h1>

<p>V predošlých častiach sme demonštrovali triedy slúžiace na načítavanie a zápis bajtov. Veľmi často sa však namiesto bajtov pracuje so znakmi a reťazcami, napr. pri práci s textovým súborom.</p>

<p>Na načítavanie znakov z vhodného zdroja je k dispozícii trieda <code>java.io.Reader</code>. Jej metódy sú veľmi podobné metódam <code>InputStream</code>u, ibaže pracujú priamo so znakmi.</p>

<ul>
<li><code>int read()</code> načíta jeden znak. Znak je vrátený ako číslo medzi 0..65535, ktoré je možné pretypovať priamo na <code>char</code>: <code>char c = (char) reader.read()</code>. Ak nastane koniec súboru, vráti sa -1.</li>
<li><code>int read(char[] cbuf)</code> naplní pole načítanými znakmi a vráti počet skutočne načítaných bajtov.</li>
<li><code>close()</code> uzatvorí <em>reader</em> a uvoľní systémové prostriedky.</li>
</ul>

<p>Metódy vracajú výnimku <code>IOException</code> a opäť poznamenávame, že uzatváranie <em>readerov</em> je skoro povinné.</p>

<p>Reader je všeobecná abstraktná trieda a preto treba vytvoriť inštanciu z niektorej jeho dediacej triedy.</p>

<h2 id="načítavanie-znakov-zo-súboru">Načítavanie znakov zo súboru</h2>

<p>Trieda <code>java.io.FileReader</code> umožňuje načítavať znaky zo súboru, pričom sa použije kódovanie nastavené v operačnom systéme (napr. na Windowse je to <code>cp1250</code>). Nasledovný príklad načíta zo súboru všetky znaky a vypíše ich na konzolu:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Reader <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  in <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileReader(<span style="background-color:#e0e0ff">&#34;d:\\adresa.txt&#34;</span>);
  <span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">aByte</span>;
  <span style="color:#289;font-weight:bold">while</span>((aByte <span style="color:#333">=</span> in.<span style="color:#007">read</span>()) <span style="color:#333">!=</span> <span style="color:#333">-</span>1) {
    System.<span style="color:#007">out</span>.<span style="color:#007">print</span>((<span style="color:#66f;font-weight:bold">char</span>) aByte);
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> { 
    in.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">// do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Alternatívne môžeme použiť aj konštruktor nad objektom <code>File</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Reader <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileReader(<span style="background-color:#e0e0ff">&#34;d:\\adresa.txt&#34;</span>);</code></pre></div>
<p>Poznamenajme, že uvedený príklad vypíše diakritické a podobné znaky správne len v prípade, ak kódovanie súboru je zhodné s kódovaním používaným v operačnom systéme. Ak by sme napr. chceli načítať znaky zo súboru v kódovaní UTF-8 na Windowse (kde je štandardné kódovanie <code>cp1250</code>), slovenské znaky by sa zobrazili ako otázniky. Aj tento problém sa dá vyriešiť (ak poznáme kódovanie súboru), zmienime sa o tom nižšie.</p>

<h2 id="načítavanie-riadkov-pomocou-readerov-s-buffrom">Načítavanie riadkov pomocou <em>readerov</em> s buffrom</h2>

<p>Načítavanie riadkov pomocou predošlej metódy je síce možné, ale pomerne náročné. Idea by bola zrejme taká, že by sme kumulovali znaky v reťazci/<code>StringBuilder</code>i až do chvíle, kým by sme nenačítali koniec riadka, prípadne koniec súboru. Na tento účel by sme si dokonca mohli spraviť vlastnú triedu <code>LineSupportingFileReader</code> (<code>FileReader</code> s podporou načítavania riadkov).</p>

<p>S tým sa však vôbec nemusíme trápiť, pretože máme  k dispozícii triedu <code>java.io.BufferedReader</code>. Tá je reprezentantom filozofie založenej na návrhovom vzore <em>wrapper</em>. <code>BufferedReader</code> je <em>reader</em>, ktorý dodá inému readeru schopnosť načítavať reťazce po riadkoch. Inak povedané, je to reader, ktorý načítava znaky z iného readera a tieto znaky kumuluje do riadkov. Ľubovoľný reader teda môže byť obalený <code>BufferedReaderom</code> a tým získať schopnosť riadkového čítania.</p>

<p>Všimnime si flexibilitu tohto návrhu. Ak by sme chceli navrhnúť reader načítavajúci riadky zo súboru, mohli by sme vytvoriť triedu dediacu z <code>FileReader</code>a a dorobiť do nej príslušnú metódu. Lenže čo v prípade, keby sme chceli načítavať riadky z readera nad internetovým pripojením? Museli by sme vytvoriť triedu <code>LineSupportingInternetConnectionReader</code> a v nej opäť dopracovať metódu. Ak by sme mali veľa readerov nad rôznymi zdrojmi, nastala by explózia počtu dediacich tried.</p>

<p>Prístup založený na návrhovom vzoru <em>wrapper</em> je elegantnejší – použijeme totiž len jednu triedu poskytujúcu danú schopnosť a zaobalíme ňou ľubovoľný reader z ľubovoľného zdroja.</p>

<p>Požadovaný riadkovo orientovaný reader nad súborom vytvoríme nasledovne:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">FileReader <span style="color:#5ed;font-weight:bold">fileReader</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileReader(<span style="background-color:#e0e0ff">&#34;C:\\autoexec.bat&#34;</span>);
BufferedReader <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedReader(fileReader);</code></pre></div>
<p>Hlavnou metódou <code>BufferedReader</code>a je metóda <code>String readLine()</code>, ktorá vráti ďalší načítaný riadok alebo <code>null</code>, ak sa dosiahol koniec vstupného prúdu.</p>

<p>Kompletný príklad, kde sa vypíše na konzolu obsah súboru je nasledovný:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">BufferedReader <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  in <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedReader(<span style="color:#289;font-weight:bold">new</span> FileReader(<span style="background-color:#e0e0ff">&#34;c:\\autoexec.bat&#34;</span>));
  String <span style="color:#5ed;font-weight:bold">line</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
  <span style="color:#289;font-weight:bold">while</span>((line <span style="color:#333">=</span> in.<span style="color:#007">readLine</span>()) <span style="color:#333">!=</span> <span style="color:#289;font-weight:bold">null</span>) {
    System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(line);
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> { 
    in.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">// do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Ak zavoláme metódu <code>close()</code> na <code>BufferedReader</code>i, tak sa zároveň zatvorí aj obalený reader, teda sa zatvorí aj <code>FileReader</code>.</p>

<h1 id="zápis-znakov-pomocou-writerov">Zápis znakov pomocou <em>writerov</em></h1>

<p>Tak ako <code>InputStream</code> slúži na načítavanie bajtov a jeho proťajškom <code>OutputStream</code> umožňuje ich zápis, k <code>Reader</code>u existuje <code>Writer</code> slúžiaci na zápis znakov.</p>

<p>Trieda <code>java.io.Writer</code> má nasledovné významné metódy:</p>

<ul>
<li><code>void write(int c)</code> zapíše jeden znak.</li>
<li><code>void write(String s)</code> zapíše celý reťazec.</li>
<li><code>void write(char[] cbuf)</code> zapíše pole znakov.</li>
<li><code>void flush()</code> zapíše dáta z medzipamäte na príslušný výstup.</li>
<li><code>void close()</code> uzatvorí výstupný prúd. Silne odporúčané volať po skončení práce, inak sa môžu stratiť dáta, resp. môže nastať odopretie zápisu pre iné procesy.</li>
</ul>

<p>Všetky metódy tiež hádžu výnimku <code>java.io.IOException</code>.</p>

<h2 id="zápis-znakov-pomocou-do-súboru">Zápis znakov pomocou do súboru</h2>

<p>Writer zapisujúci do súboru sa volá, prekvapivo, <code>java.io.FileWriter</code> a jeho použitie je skoro také isté, ako <code>FileOutputStream</code>u. Príklad, ktorý zapíše do súboru päťkrát daný text je uvedený nižšie:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Writer <span style="color:#5ed;font-weight:bold">out</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  out <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileWriter(<span style="background-color:#e0e0ff">&#34;du.txt&#34;</span>);
  String <span style="color:#5ed;font-weight:bold">message</span> <span style="color:#333">=</span> <span style="background-color:#e0e0ff">&#34;Budem si písať domácu úlohu.\n&#34;</span>;
  <span style="color:#289;font-weight:bold">for</span> (<span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">i</span> <span style="color:#333">=</span> 0; i <span style="color:#333">&lt;</span> 5; i<span style="color:#333">++</span>) {
    out.<span style="color:#007">write</span>(message);
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> { 
    out.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">// do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Všimnite si, že ak chceme zapísať reťazce po riadkoch, musíme ich ukončiť znakom <code>\n</code>. Tento znak zodpovedá UNIXovému koncu riadku. V prípade Windowsu to však nie je veľmi korektné, keďže riadky by mali byť ukončené znakmi <code>CR</code> a <code>LF</code> (<code>\r\n</code>). Program, ktorý je platformovo nezávislý, by mal vyzerať lepšie:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String <span style="color:#5ed;font-weight:bold">EOL</span> <span style="color:#333">=</span> System.<span style="color:#007">getProperty</span>(<span style="background-color:#e0e0ff">&#34;line.separator&#34;</span>);
...
String <span style="color:#5ed;font-weight:bold">message</span> <span style="color:#333">=</span> <span style="background-color:#e0e0ff">&#34;Budem si písať domácu úlohu.&#34;</span> <span style="color:#333">+</span> EOL;</code></pre></div>
<p>Tento postup však budeme používať málokedy, pretože na zápis celých riadkov existuje trieda <code>BufferedWriter</code>.</p>

<h2 id="zápis-riadkov-pomocou-writerov-s-buffrom">Zápis riadkov pomocou <em>writerov</em> s buffrom</h2>

<p>Ukázali sme si, že na riadkové načítavanie jestvuje <code>BufferedReader</code>, ktorým možno obaliť ľubovoľný reader a tým mu dodať túto schopnosť. Na zápis riadkov je k dispozícii opäť protipól a to <code>java.io.BufferedWriter</code>. Jeho hlavná výhoda spočíva v možnosti buffrovať výstup. Obyčajný writer totiž zapisuje znaky na výstup ihneď, čo môže byť niekedy neefektívne. Zrejme je lepšie kumulovať znaky určené na zápis do nejakej medzipamäte, teda buffra a až po jej naplnení ich odoslať na výstup. Dokumentácia odporúča používať <code>BufferedWriter</code> vždy, keď je operácia zápisu relatívne náročná (spomína sa špeciálne prípad <code>FileWriter</code>a).</p>

<p><code>BufferedWriter</code> poskytuje oproti klasickému <code>Writer</code>u jedinú novú metódu <code>void newLine()</code>, ktorou sa na výstup zapíše znak konca riadka. Vytvoriť inštanciu je možné napr. nasledovne</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">BufferedWriter <span style="color:#5ed;font-weight:bold">out</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedWriter(<span style="color:#289;font-weight:bold">new</span> FileWriter(<span style="background-color:#e0e0ff">&#34;D:\\data.txt&#34;</span>));</code></pre></div>
<p>Zápis riadku je potom možný pomocou</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">out.<span style="color:#007">write</span>(<span style="background-color:#e0e0ff">&#34;Ahoj&#34;</span>);
out.<span style="color:#007">newLine</span>();</code></pre></div>
<p>To však stále nie je úplne ideálny stav. Našťastie je k dispozícii pomocná trieda <code>PrintWriter</code>.</p>

<h2 id="zápis-textových-dát-pomocou-printwriter-a">Zápis textových dát pomocou <code>PrintWriter</code>a</h2>

<p>Trieda <code>java.io.PrintWriter</code> je veľmi užitočný writer, ktorý dokáže obaliť ľubovoľný iný <code>Writer</code> alebo <code>OutputStream</code> a dodať mu schopnosť zapisovať textové reprezentácie mnohých dátových typov. Popri metódach zdedených od klasického <code>Writera</code> poskytuje metódy ako:</p>

<ul>
<li><code>void println(String x)</code> zapíše na nový riadok reťazec. Táto metóda je preťažená pre všetky primitívne dátové typy a dokonca aj pre <code>Object</code> (v tomto prípade zapíše výsledok metódy <code>toString()</code>).</li>
<li><code>void print(String x)</code> zapíše reťazec (v prípade, že je <code>null</code>, zapíše <code>&quot;null&quot;</code>). Táto metóda je tiež preťažená pre primitívne dátové typy a pre <code>Object</code>.
Ďalšou vlastnosťou <code>PrintWriter</code>a je to, že jeho metódy nehádžu výnimky <code>IOException</code>. Chybový stav je možné kontrolovať volaním metódy <code>boolean checkError()</code>.</li>
</ul>

<p>Nasledovný príklad zapíše do súboru desať riadkov. Na nepárnych riadkoch je text <code>&quot;Line:&quot;</code>, na párnych sú čísla.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">PrintWriter <span style="color:#5ed;font-weight:bold">out</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  out <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> PrintWriter(
          <span style="color:#289;font-weight:bold">new</span> BufferedWriter(<span style="color:#289;font-weight:bold">new</span> FileWriter(<span style="background-color:#e0e0ff">&#34;cisla.txt&#34;</span>)));
  <span style="color:#289;font-weight:bold">for</span> (<span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">i</span> <span style="color:#333">=</span> 0; i <span style="color:#333">&lt;</span> 5; i<span style="color:#333">++</span>) {
    out.<span style="color:#007">println</span>(<span style="background-color:#e0e0ff">&#34;Line:&#34;</span>);
    out.<span style="color:#007">println</span>(i);
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> { 
    out.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">// do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>V príklade <code>PrintWriter</code> obaľuje <code>BufferedWriter</code> (aby sme získali väčšiu efektivitu pri zapisovaní, v opačnom prípade by sa každý zápis odoslal ihneď do súboru, čo nemusí byť efektívne) a ten obaľuje writer nad súborom.</p>

<p>Zatvorenie <code>PrintWriter</code>a pomocou <code>close()</code> kaskádne zavrie <code>BufferedWriter</code> a následne <code>FileWriter</code>.</p>

<h1 id="čítanie-a-zápis-byteov-s-buffrovaním">Čítanie a zápis byteov s buffrovaním</h1>

<p>Dosiaľ sme spomenuli možnosť buffrovania pri čítaní resp. zapisovaní reťazcov a znakov. Ale i obyčajné vstupno-výstupné prúdy je možné obohatiť o podporu buffrovania.</p>

<p>Trieda <code>java.io.BufferedInputStream</code> používa pri načítavaní bajtov zo vstupu buffer a teda následné volania <code>read()</code> pristupujú vo veľkej miere k buffru a nie priamo k vstupnému zdroju. Naviac táto trieda poskytuje podporu pre metódy <code>mark()</code> a <code>reset()</code>, o ktorých budeme písať v ďalšej sekcii.</p>

<p>Jej zapisovací kamarát <code>java.io.BufferedOutputStream</code> ukladá bajty z metódy <code>write()</code> do buffra, ktorý zapíše na výstup až po jeho naplnení. Tým znižuje počet volaní zápisu na obaľovanom výstupnom prúde.</p>

<p>Obe triedy sú založené na filozofii obaľovača. Príklad použitia je napr.:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">BufferedOutputStream <span style="color:#5ed;font-weight:bold">out</span> 
  <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedOutputStream(<span style="color:#289;font-weight:bold">new</span> FileOutputStream(<span style="background-color:#e0e0ff">&#34;D:\\data.txt&#34;</span>));</code></pre></div>
<h2 id="metódy-mark-a-reset">Metódy <code>mark()</code> a <code>reset()</code></h2>

<p>Metódy <code>read()</code> na vstupnom prúde sa po vstupnom prúde posúvajú smerom „dopredu&rdquo;. Niekedy však môže nastať situácia, keď sa chceme vrátiť v prúde späť a teda napr. načítať niektoré dáta z prúdu ešte raz. Na to môžeme použiť dvojicu metód <code>mark()</code> a <code>reset()</code>.</p>

<p>Metóda <code>mark()</code> si umožňuje poznačiť aktuálnu pozíciu vo vstupnom prúde (na dané miesto umiestnime „záložku&rdquo;). Metódou <code>reset()</code> sa zase môžeme vrátiť v prúde naspäť na poznačenú pozíciu. Ak načítame z prúdu dva bajty, položíme záložku pred tretí bajt cez <code>mark()</code>, načítame štvrtý a následne piaty bajt a zavoláme <code>reset()</code>, ďalšie volanie metódy <code>read()</code> načíta opäť štvrtý bajt (prípadné ďalšie volania budú pokračovať piatym, šiestym atď bajtom).</p>

<p>Takáto záložka môže byť v prúde len jedna a je treba poznamenať, že nie všetky vstupné prúdy podporujú túto funkcionalitu. Predstavme si, že televízny signál prichádzajúci do nášho televízora sú bajty. Ak si chceme zopakovať zaujímavý gól, zrejme nemôžeme požiadať vysielateľa, aby nám to spravil na požiadanie. To isté sa týka niektorých vstupných prúdov (napr. bajtov prúdiacich zo sieťového pripojenia). Vstupný prúd <code>InputStream</code> má metódu <code>boolean markAvailable()</code>, ktorá vráti <code>true</code>, ak prúd podporuje značkovanie a návrat na označkovanú pozíciu.</p>

<p>Ak používaný vstupný prúd nepodporuje značkovanie, netreba zúfať. V prípade televízneho signálu by sme mohli získať možnosť púšťať zaujímavé výseky nanovo zapojením DVD rekordéra, ktorý môže slúžiť ako medzipamäť. V prípade potreby prezerania zaujímavých častí budeme čítať dáta z DVD, na ktoré sa bude ukladať prichádzajúce dáta; DVD rekordér teda slúži ako buffer.</p>

<p>Túto analógiu môžeme použiť aj v prípade vstupných prúdov. Ak obalíme vstupný prúd už spomínaným <code>BufferedInputStream</code>om, získame možnosť vracať sa na označkované miesta aj v prípade, že obalený vstupný prúd túto funkciu priamo neponúka.</p>

<p>Poznamenajme ešte, že metóda <code>mark()</code> má jeden celočíselný parameter. Po načítaní daného počtu bajtov sa príslušná značka v prúde zneplatní, teda zabudne. Ak si označkujeme vstupný prúd 16timi bajtmi, po načítaní šestnástich bajtov sa značka v prúde zruší.</p>

<h1 id="premostenie-bytov-a-znakov-inputstreamreader-a-outputstreamwriter">Premostenie bytov a znakov – <code>InputStreamReader</code> a <code>OutputStreamWriter</code></h1>

<p>Ak sa spätne pozrieme na spôsoby, ktorými je možné načítavať dát z vhodného zdroja, zistíme, že ich môžeme logicky rozdeliť na:</p>

<ul>
<li>metódy pracujúce s bajtmi (<code>InputStream</code>y a <code>OutputStream</code>y)</li>
<li>metódy pracujúce so znakmi a reťazcami (<code>Reader</code>y a <code>Writer</code>y)
Mohlo by sa zdať, že readery a writery sú zbytočné, veď ich funkcionalitu vieme dosiahnuť len s pomocou vstupných (výstupných) prúdov. Na to by však bolo potrebné vyriešiť niekoľko problémov a to hlavne s mapovaním bajtov na znaky a späť. Tieto náležitosti sa týkajú <em>kódových stránok</em>. Napr. v klasickom ASCII kódovaní zodpovedá bajt 65 znaku <code>A</code> a každému bajtu zodpovedá jeden znak (v bajte je možné vyjadriť 256 rôznych hodnôt, teda máme 256 znakov). Tento prístup je jednoduchý, ale obmedzuje neanglických používateľov (v ASCII asi nie je možné reprezentovať vetu <code>Ľaľa, už čmýri sa čmeľ</code>, pretože znakom ako <code>ľ</code>, či <code>č</code> nezodpovedá žiaden bajt.) Java rieši tento problém vo svojich útrobách pomocou kódovania Unicode, kde je jeden znak namapovaný na dva bajty. Lenže pri načítavaní súborov je treba vykonávať rôzne konverzie – na Windowse v kódovej stránke <code>cp1250</code> máme mapovanie 1 znak-1 bajt, kde treba vyriešiť prevody do Unicode. V kódovaní <code>utf-8</code> dokonca niektorým znakom zodpovedá jeden bajt a niektorým dva. Zrejme vidieť, že manuálne riešenie týchto problémov by spôsobilo trhanie vlasov.</li>
</ul>

<p>Toto všetko Java uľahčuje a dáva k dispozícii triedy, ktoré reprezentuju premostenie medzi svetom bajtov a svetom znakov.</p>

<h2 id="premostenie-vstupných-prúdov-a-readerov">Premostenie vstupných prúdov a readerov</h2>

<p>Trieda <code>java.io.InputStreamReader</code> umožňuje obaliť ľubovoľný <code>InputStream</code>, načítavať z neho bajty a prevádzať ich na znaky s použitím zadaného kódovania.</p>

<p>Ak chceme načítavať znaky zo súboru, ktorý je v kódovaní <code>utf-8</code>, môžeme použiť nasledovný kód:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">FileInputStream <span style="color:#5ed;font-weight:bold">fileInputStream</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileInputStream(<span style="background-color:#e0e0ff">&#34;D:\\utf8.txt&#34;</span>);
<span style="color:#666;font-style:italic">// súborovému vstupnému prúdu dodáme podporu buffrovania kvôli
</span><span style="color:#666;font-style:italic">// väčšej efektivite
</span><span style="color:#666;font-style:italic"></span>BufferedInputStream <span style="color:#5ed;font-weight:bold">bufferedIn</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedInputStream(fileInputStream);
InputStreamReader <span style="color:#5ed;font-weight:bold">in</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> InputStreamReader(bufferedIn, <span style="background-color:#e0e0ff">&#34;utf-8&#34;</span>);</code></pre></div>
<p><code>InputStreamReader</code> má metódy <code>Reader</code>a a umožňuje vrátiť používané kódovanie znakov pomocou metódy <code>String getEncoding()</code>.</p>

<p>Načítavanie reťazcových riadkov z <code>InputStream</code>u získame vhodným skombinovaním viacerých tried: <code>FileInputStream</code> bude načítavať bajty zo súboru, <code>InputStreamReader</code> ich prevedie na bajty a <code>BufferedReader</code> zabezpečí podporu buffrovania a metódu na načítavanie reťazcov.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">FileInputStream <span style="color:#5ed;font-weight:bold">fileInputStream</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileInputStream(<span style="background-color:#e0e0ff">&#34;d:\\utf8.txt&#34;</span>);
InputStreamReader <span style="color:#5ed;font-weight:bold">inReader</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> InputStreamReader(fileInputStream);
BufferedReader <span style="color:#5ed;font-weight:bold">reader</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedReader(inReader);</code></pre></div>
<p>Alebo na jeden riadok:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">BufferedReader <span style="color:#5ed;font-weight:bold">reader</span> 
  <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedReader(
      <span style="color:#289;font-weight:bold">new</span> InputStreamReader(
        <span style="color:#289;font-weight:bold">new</span> FileInputStream(<span style="background-color:#e0e0ff">&#34;d:\utf8.txt&#34;</span>)));</code></pre></div>
<p>Možno máte pocit <em>deja-vu</em> – veď to isté sme mohli dosiahnuť pomocou kombinácie <code>FileReader</code>a a <code>BufferedReader</code>a. Nuž, je to tak. Ak si pozriete dokumentáciu k triede <code>java.io.FileReader</code>, zistíte, že je to vlastne pomocná trieda dediaca od <code>InputStreamReader</code>a, ktorá vo svojich vnútornostiach používa otvára <code>FileInputStream</code> a bajty načítavané zo súboru konvertuje na znaky s použitím implicitného kódovania v operačnom systéme. Ak však potrebujeme špecifikovať iné kódovanie než implicitné, <code>FileReader</code> nám už postačovať nebude a musíme použiť kombináciu z vyššieuvedeného príkladu.</p>

<h2 id="premostenie-výstupných-prúdov-a-writerov">Premostenie výstupných prúdov a writerov</h2>

<p>Tak ako <code>InputStreamReader</code> zabezpečuje prevod bajtov na znaky, <code>java.io.OutputStreamWriter</code> zodpovedá za opačný proces: znaky konvertuje na bajty podľa príslušného kódovania.</p>

<p>Filozofia je podobná ako v prípade vstupu, <code>OutputStreamWriter</code> obalí ľubovoľný <code>OutputStream</code> a obohatí ho o schopnosť zapisovať doň znaky. Príkladom zápisu znakov do súboru je:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">FileOutputStream <span style="color:#5ed;font-weight:bold">fileOutputStream</span> 
  <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> FileOutputStream(<span style="background-color:#e0e0ff">&#34;utf8-out.txt&#34;</span>);
<span style="color:#666;font-style:italic">// súborovému výstupnému prúdu dodáme podporu buffrovania kvôli
</span><span style="color:#666;font-style:italic">// väčšej efektivite
</span><span style="color:#666;font-style:italic"></span>BufferedOutputStream <span style="color:#5ed;font-weight:bold">bufferedOut</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedOutputStream(fileOutputStream);
OutputStreamWriter <span style="color:#5ed;font-weight:bold">outWriter</span> 
  <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> OutputStreamWriter(bufferedOut, <span style="background-color:#e0e0ff">&#34;utf-8&#34;</span>);</code></pre></div>
<p><code>OutputStreamWriter</code> má analogické metódy ako <code>Writer</code> a umožňuje nastaviť a vrátiť používané kódovanie.</p>

<p>Pomocným proťajškom k <code>FileReader</code>u je <code>FileWriter</code>, ktorý nie je ničím iným, ako zabalením <code>FileOutputStream</code>u do <code>OutputStreamWriter</code>a s použitím štandardného kódovania v operačnom systéme.</p>

<h1 id="serializácia-zápis-a-načítavanie-celých-objektov">Serializácia – zápis a načítavanie celých objektov</h1>

<p>Dosiaľ sme pracovali len bajtmi, znakmi a reťazcami. Java však umožňuje odosielať do výstupných prúdov a načítavať zo vstupných prúdov celé objekty. Typickým príkladom je situácia, keď chceme <em>niekam</em> uložiť stav kompletného objektu a neskôr (napr. pri ďalšom spustení aplikácie) si ho obnoviť. Tento proces sa nazýva <em>serializácia</em> a Java ho do značnej miery uľahčuje. Serializácia umožňuje previesť ľubovoľný objekt na postupnosť bajtov, s ktorou môžeme spraviť to, čo uznáme za vhodné – uložiť ho do súboru, poslať po sieti a pod.</p>

<p>Serializovať možno ľubovoľný objekt, ktorý implementuje interfejs <code>java.io.Serializable</code>. Tento interfejs nemá žiadne metódy, indikuje len schopnosť objektu byť serializovaným. Mapovanie objektu na bajty (a prípadný spätný proces) sa deje automaticky.</p>

<p>Majme napríklad jednoduchú triedu osoby:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#289;font-weight:bold">import</span> <span style="color:#5ed;font-weight:bold">java</span>.<span style="color:#007">io</span>.<span style="color:#007">Serializable</span>;

<span style="color:#289;font-weight:bold">public</span> <span style="color:#5ed;font-weight:bold">class</span> Person <span style="color:#5ed;font-weight:bold">implements</span> Serializable {
  <span style="color:#289;font-weight:bold">private</span> <span style="color:#5ed;font-weight:bold">String</span> name;
  
  <span style="color:#289;font-weight:bold">private</span> <span style="color:#5ed;font-weight:bold">int</span> age;

  <span style="color:#289;font-weight:bold">public</span> <span style="color:#5ed;font-weight:bold">Person</span>(String <span style="color:#5ed;font-weight:bold">name</span>, <span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">age</span>) {
    <span style="color:#289;font-weight:bold">super</span>();
    <span style="color:#289;font-weight:bold">this</span>.<span style="color:#007">name</span> <span style="color:#333">=</span> name;
    <span style="color:#289;font-weight:bold">this</span>.<span style="color:#007">age</span> <span style="color:#333">=</span> age;
  }

  <span style="color:#666;font-style:italic">// gettre a settre    
</span><span style="color:#666;font-style:italic"></span>}</code></pre></div>
<p>Na ukladanie inštancie tejto triedy do výstupného prúdu jestvuje užitočná trieda <code>java.io.ObjectOutputStream</code>. Tá reprezentuje <code>OutputStream</code>, ktorý dokáže dodať ľubovoľnému inému <code>OutputStream</code>u schopnosť ukladať objekty. Protipólom slúžiacim na čítanie je <code>java.io.ObjectInputStream</code>, ktorý dodá inému <code>InputStream</code>u schopnosť načítavať z neho objekty.</p>

<p><code>ObjectOutputStream</code> má množstvo zaujímavých metód začínajúcich sa na <code>write</code> (napr. <code>void writeBoolean(boolean b)</code>. Zvyčajne zrejme budeme používať metódu <code>void writeObject(Object o)</code>, ktorá zapíše na výstup ľubovoľný objekt implementujúci interfejs <code>Serializable</code>.</p>

<p>Nasledovný príklad odserializuje do výstupného prúdu postupne jedno číslo, jeden reťazec a jednu inštanciu triedy <code>Person</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ObjectOutputStream <span style="color:#5ed;font-weight:bold">oos</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  ByteArrayOutputStream <span style="color:#5ed;font-weight:bold">byteArrayOut</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> ByteArrayOutputStream();
  oos <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> ObjectOutputStream(byteArrayOut);

  oos.<span style="color:#007">writeInt</span>(12345);
  oos.<span style="color:#007">writeObject</span>(<span style="background-color:#e0e0ff">&#34;Today&#34;</span>);
  oos.<span style="color:#007">writeObject</span>(<span style="color:#289;font-weight:bold">new</span> Person(<span style="background-color:#e0e0ff">&#34;Johnny Walker&#34;</span>, 25));

  System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(Arrays.<span style="color:#007">toString</span>(byteArrayOut.<span style="color:#007">toByteArray</span>()));
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> {
    oos.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">//do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Výstupným prúdom je v tomto prípade <code>java.io.ByteArrayOutputStream</code>, ktorá zapisuje do poľa bajtov. Obalením tohto výstupného prúdu schopnosťou zapisovať objekty získame možnosť získavať binárnu reprezentáciu inštancií a obsahov premenných. Výsledné pole bajtov získame z <code>ByteArrayOutputStream</code>u pomocou metódy <code>toByteArray()</code>.</p>

<p>Trieda <code>ObjectInputStream</code> slúžiaca na načítanie objektov zo vstupu má užitočné metódy začínajúce sa na <code>read</code>. Zvyčajnou je metódy <code>Object readObject()</code>, ktorá načíta z prúdu objekt. V príklade máme binárne dáta uložené v poli bajtov. Nad týmto poľom postavíme <code>java.io.ByteArrayInputStream</code> a ten obalíme <code>ObjectInputStream</code>, ktorý bude interpretovať tieto bajty a deserializovať ich do objektu.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#666;font-style:italic">//v poli bajtov máme dáta 
</span><span style="color:#666;font-style:italic"></span><span style="color:#66f;font-weight:bold">byte</span>[] <span style="color:#5ed;font-weight:bold">data</span> <span style="color:#333">=</span> {
    <span style="color:#333">-</span>84, <span style="color:#333">-</span>19, 0, 5, 119, 4, 0, 0, 48, 57, 116, 0, 5, 84, 111, 100, 
    97, 121, 115, 114, 0, 6, 80, 101, 114, 115, 111, 110, 42, <span style="color:#333">-</span>104,
    21, <span style="color:#333">-</span>71, 92, 46, <span style="color:#333">-</span>63, 108, 2, 0, 2, 73, 0, 3, 97, 103, 101, 76, 
    0, 4, 110, 97, 109, 101, 116, 0, 18, 76, 106, 97, 118, 97, 47, 
    108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 120, 
    112, 0, 0, 0, 25, 116, 0, 13, 74, 111, 104, 110, 110, 121, 32, 
    87, 97, 108, 107, 101, 114
};

ObjectInputStream <span style="color:#5ed;font-weight:bold">ois</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  ByteArrayInputStream <span style="color:#5ed;font-weight:bold">byteArrayIn</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> ByteArrayInputStream(data);
  ois <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> ObjectInputStream(byteArrayIn);
  <span style="color:#666;font-style:italic">//načítame jeden int
</span><span style="color:#666;font-style:italic"></span>  System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(ois.<span style="color:#007">readInt</span>());
  <span style="color:#666;font-style:italic">//načítame jeden Object (v skutočnosti je to reťazec)
</span><span style="color:#666;font-style:italic"></span>  System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(ois.<span style="color:#007">readObject</span>());
  <span style="color:#666;font-style:italic">//načítame jeden objekt Person
</span><span style="color:#666;font-style:italic"></span>  Person <span style="color:#5ed;font-weight:bold">person</span> <span style="color:#333">=</span> (Person) ois.<span style="color:#007">readObject</span>();

  System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(person.<span style="color:#007">getName</span>());
  System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(person.<span style="color:#007">getAge</span>());

} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">catch</span> (ClassNotFoundException <span style="color:#5ed;font-weight:bold">e</span>) {
  <span style="color:#666;font-style:italic">// pokúšame sa vytvoriť inštanciu triedy, ktorú
</span><span style="color:#666;font-style:italic"></span>  <span style="color:#666;font-style:italic">// nemáme v systéme k dispozícii
</span><span style="color:#666;font-style:italic"></span>  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#289;font-weight:bold">try</span> {
    ois.<span style="color:#007">close</span>();
  } <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
    <span style="color:#666;font-style:italic">//do nothing
</span><span style="color:#666;font-style:italic"></span>  }
}</code></pre></div>
<p>Treba poznamenať, že trieda <code>readObject()</code> hádže výnimku <code>ClassNotFoundException</code>. Môže sa stať, že sa budeme snažiť načítavať triedu, ku ktorej neexistuje v systéme binárny kód a teda Java nebude vedieť vytvoriť inštanciu tejto triedy.</p>

<p>Serializovať a deserializovať možno ľubovoľné komplexné objektové prepojenia (napr. <code>Person</code>, ktorý obsahuje odkaz na rodiča). Java ich korektne uloží a to vrátane všetkých prepojení a asociácii. Niekedy sa môže stať, že niektorá z asociovaných tried neimplementuje <code>java.io.Serializable</code>. V tom prípade sa pri pokuse o serializáciu vyhodí výnimka <code>java.io.NotSerializableException</code>. Príkladom môže byť osoba <code>Person</code>, ktorá má adresu <code>Address</code>, čo je neserializovateľná trieda. Pri pokuse o serializáciu inštancie osoby nastane chyba.</p>

<h1 id="ostatné-užitočné-triedy-balíčka-java-io">Ostatné užitočné triedy balíčka <code>java.io</code></h1>

<p>Balíček <code>java.io</code> obsahuje aj niektoré iné užitočné triedy, ktoré sa trochu vymykajú uvedenej hierarchii.</p>

<h2 id="system-out-a-printstream"><code>System.out</code> (a <code>PrintStream</code>)</h2>

<p>Premennú <code>System.out</code> používal zrejme každý už od čias prvého Java programu, ktorý vypisoval <code>&quot;Ahoj svet!&quot;</code>. Ak sa pozrieme na dátový typ tejto premennej, zistíme, že ide o <code>java.io.PrintStream</code>. Táto trieda je <code>OutputStream</code>om, do ktorého je možné zapisovať znaky, reťazce a ostatné primitívne dátové typy. Nie je to však divné? Spomínali sme totiž, že do výstupných prúdov sa zapisujú len bajty. Za zápis znakov (a ostatných primitívnych typov) má byť predsa zodpovedný <code>Writer</code> (resp. <code>PrintWriter</code>)! Pravda je taká, že táto trieda je v Jave len z historických dôvodov (už od verzie 1.0). V staršej dokumentácii sa dokonca uvádzalo, že <code>PrintStream</code> je už zastaralá (<em>deprecated</em>) trieda a namiesto nej je lepšie používať <code>PrintWriter</code> (iróniou je, že v novej dokumentácii už táto zmienka nie je a ani trieda už nie je zastaralá&hellip;). Táto trieda totiž prevádza zapisované znaky a reťazce na bajty s použitím kódovania používaného operačným systémom, čo môže niekedy spôsobiť stratu medzinárodných znakov.</p>

<p>Metódy <code>PrintStream</code>u, podobne ako <code>PrintWriter</code>a, nehádžu výnimky <code>IOException</code>. Chybový stav je možné zistiť zavolaním booleovskej metódy <code>checkError</code>.</p>

<p>Podotknime, že ak by nás napadlo zatvoriť <code>System.out</code>, tak to nemusí byť práve najšťastnejším nápadom. Ak náhodou potrebujeme presmerovať štandardný výstup, môžeme použiť statickú metódu <code>System.setOut(PrintStream out)</code>, ktorej môžeme nastaviť nový <code>PrintStream</code>.</p>

<h2 id="system-in"><code>System.in</code></h2>

<p>Táto premenná reprezentuje štandardný vstupný prúd <code>InputStream</code>, z ktorého je možné čítať dáta prichádzajúce zo štandardného vstupu (typicky z klávesnice). S týmto <code>InputStream</code>om pracujeme ako s každým iným vstupným prúdom.</p>

<p>Ak chceme načítavať riadky z klávesnice, môžeme použiť tradičnú kombináciu <code>InputStreamReader</code>a (obalí <code>System.in</code> schopnosťou načítavať znaky a reťazce) a <code>BufferedReader</code>a (dodá schopnosť načítavať riadky).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">BufferedReader <span style="color:#5ed;font-weight:bold">console</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  console <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> BufferedReader(<span style="color:#289;font-weight:bold">new</span> InputStreamReader(System.<span style="color:#007">in</span>));
  String <span style="color:#5ed;font-weight:bold">line</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
  <span style="color:#289;font-weight:bold">while</span>((line <span style="color:#333">=</span> console.<span style="color:#007">readLine</span>()) <span style="color:#333">!=</span> <span style="color:#289;font-weight:bold">null</span>) {
    System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(line);
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  <span style="color:#666;font-style:italic">/* 
</span><span style="color:#666;font-style:italic">   * zatvárať štandardný vstup nie je múdre,
</span><span style="color:#666;font-style:italic">   * vynecháme preto close()
</span><span style="color:#666;font-style:italic">   */</span>
}</code></pre></div>
<p>Tu si nemožno neodpustiť ironickú poznámku, že kým v Pascale stačí zavolať <code>readln()</code>, v Jave je vytvorenie objektu konzoly pomerne nepríjemnou záležitosťou. Začiatočníci zrejme neocenia nutnosť vytvoriť tri inštancie a odchytávať výnimky.</p>

<p>Našťastie, v každej novej verzii Javy prišlo k zlepšeniu.</p>

<h2 id="skener-java-util-scanner-od-jdk-5-0">Skener <code>java.util.Scanner</code> (od JDK 5.0)</h2>

<p>Skener <code>java.util.Scanner</code> je trieda, ktorá umožňuje načítavať z ľubovoľného textového zdroja reťazce, znaky a ostatné primitívne typy a to i v prípade, že vstupný textový zdroj je formátovaný. Túto triedu možno považovať za analógiou a rozšírenie funkcie <code>scanf()</code> z Cčka. Textovým zdrojom môže byť hocičo: <code>InputStream</code> (bajty sa prevedú na znaky s použitím kódovania operačného systému), readery, reťazce a pod.</p>

<p>Užitočným príkladom je skener nad štandardným vstupom. Ak chceme získať analógiou pascalovského <code>readln()</code>, použijeme metódu <code>String nextLine()</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Scanner <span style="color:#5ed;font-weight:bold">s</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> Scanner(System.<span style="color:#007">in</span>);		
<span style="color:#289;font-weight:bold">while</span>(s.<span style="color:#007">hasNextLine</span>()) {
  System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(s.<span style="color:#007">nextLine</span>());
}</code></pre></div>
<p>Skener sme vytvorili nad štandardným vstupom. Riadky načítavame pomocou dvoch metód: <code>hasNextLine()</code> vráti <code>true</code>, ak je možné načítať ďalší riadok (<code>false</code> sa vráti v prípade, že nastal koniec súboru). Metóda <code>nextLine()</code> zase vráti načítaný riadok.</p>

<p>Skener má popri tom ďalšie dvojice metód <code>hasNextXXX()</code> a <code>nextXXX()</code> (pre každý primitívny typ jednu). Skener, ktorý načíta z reťazca postupne podreťazec, boolean, celé číslo a byte je nasledovný. Skener vytvoríme nad vstupným reťazcom a nastavíme medzeru ako oddeľovač (použitím metódy <code>useDelimiter()</code>).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Scanner <span style="color:#5ed;font-weight:bold">s</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> Scanner(<span style="background-color:#e0e0ff">&#34;25 25 true 25&#34;</span>);
s.<span style="color:#007">useDelimiter</span>(<span style="background-color:#e0e0ff">&#34; &#34;</span>);
System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(s.<span style="color:#007">next</span>());
System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(s.<span style="color:#007">nextInt</span>());
System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(s.<span style="color:#007">nextBoolean</span>());
System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(s.<span style="color:#007">nextByte</span>());</code></pre></div>
<p>Skener nad súborom vyrobíme jednoducho: do konštruktora dodáme inštanciu <code>File</code>. Treba dať pozor na to, že ak by sme do konštruktora dali len reťazec s cestou, bude to chybou, skener sa totiž pokúsi spracovávať samotný reťazec, čo zrejme nie je to, čo chceme.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Scanner <span style="color:#5ed;font-weight:bold">scanner</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
  scanner <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> Scanner(<span style="color:#289;font-weight:bold">new</span> File(<span style="background-color:#e0e0ff">&#34;input.txt&#34;</span>));   
  <span style="color:#289;font-weight:bold">while</span>(scanner.<span style="color:#007">hasNextLine</span>()) {
    System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(scanner.<span style="color:#007">nextLine</span>());
  }
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
  e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
  scanner.<span style="color:#007">close</span>();
}</code></pre></div>
<p>Podobne ako v prípade vstupných a výstupných prúdov je slušné po skončení práce skener zavrieť, najlepšie vo <code>finally</code> bloku.</p>

<h2 id="konzola-java-io-console-od-jdk-6-0">Konzola <code>java.io.Console</code> (od JDK 6.0)</h2>

<p>Po mnohých rokoch a bedákaniach sa do JDK dodala možnosť jednoduchého načítavania textu z konzoly a to v podobe triedy <code>java.io.Console</code>. Konzola má niekoľko významných metód:</p>

<ul>
<li><code>String readLine()</code> načíta jeden riadok z konzoly. V podstate je to analógia metódy <code>readln</code> z Pascalu.</li>
<li><code>String readLine(String format, Object[] values)</code> vypíše formátovaný reťazec a načíta jeden reťazec.</li>

<li><p><code>format(String format, Object[] values)</code>, resp. <code>printf(String format, Object[] values)</code> vypíše na konzolu formátovaný reťazec.
V triede jestvujú aj ďalšie metódy (na načítanie hesla, získanie vstupného readera a výstupného writera). Objekt konzoly môžeme získať pomocou <code>System.console()</code>, v niektorých prostrediach sa však môže stať, že konzola k dispozícii nebude (napr. Eclipse vo verzii 3.3 ešte takúto konzolu nepodporuje).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">System.<span style="color:#007">console</span>().<span style="color:#007">printf</span>(<span style="background-color:#e0e0ff">&#34;Zadajte riadok:&#34;</span>);
String <span style="color:#5ed;font-weight:bold">line</span> <span style="color:#333">=</span> System.<span style="color:#007">console</span>().<span style="color:#007">readLine</span>();
System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(line);

<span style="color:#66f;font-weight:bold">int</span> <span style="color:#5ed;font-weight:bold">numberCount</span> <span style="color:#333">=</span> 3;
String <span style="color:#5ed;font-weight:bold">numberLine</span> <span style="color:#333">=</span> System.<span style="color:#007">console</span>()
.<span style="color:#007">readLine</span>(<span style="background-color:#e0e0ff">&#34;Zadajte %s reťazcov oddelených medzerami:&#34;</span>, 
         numberCount);
String[] <span style="color:#5ed;font-weight:bold">numbers</span> <span style="color:#333">=</span> numberLine.<span style="color:#007">split</span>(<span style="background-color:#e0e0ff">&#34; &#34;</span>);
<span style="color:#289;font-weight:bold">if</span>(numbers <span style="color:#333">!=</span> <span style="color:#289;font-weight:bold">null</span> <span style="color:#333">&amp;&amp;</span> numbers.<span style="color:#007">length</span> <span style="color:#333">==</span> 3) {
<span style="color:#289;font-weight:bold">for</span> (Object <span style="color:#5ed;font-weight:bold">object</span> <span style="color:#333">:</span> numbers) {
System.<span style="color:#007">console</span>().<span style="color:#007">printf</span>(<span style="background-color:#e0e0ff">&#34;%s %s\n&#34;</span>, object.<span style="color:#007">getClass</span>(), object);
}
}</code></pre></div></li>
</ul>

<h2 id="súbor-s-náhodným-prístupom-random-access-file">Súbor s náhodným prístupom (<em>random access file</em>)</h2>

<p>Idey tried pre vstupno-výstupné operácie doteraz operovali hlavne s prúdmi dát. V prípade súborov sme mohli dáta zapisovať sekvenčne a načítavať rovnako len „po prúde&rdquo;. Drobnou výnimkou boli vstupné prúdy, kde sme sa mohli na jedno miesto vrátiť viackrát a to po použití metód <code>mark()</code> a <code>reset</code>.</p>

<p>Súbor s náhodným prístupom je skôr bližší pojmu poľa bytov, po ktorom sa môžeme hýbať „kurzorom&rdquo; v ľubovoľnom smere – dopredu i dozadu a to v ľubovoľnej chvíli. Do takéhoto súboru možno podľa potreby čítať a zapisovať a to v ľubovoľnom poradí.
Na tento účel existuje trieda <code>java.io.RandomAccessFile</code>. Jej najdôležitejšie metódy sú:</p>

<ul>
<li>konštruktor <code>RandomAccessFile(File file, String mode)</code>, ktorý otvorí daný súbor v príslušnom móde. Módy sú podobné tým z jazyka C používané pri funkcii <code>fopen()</code>. Napr. mód <code>&quot;rw&quot;</code> otvorí súbor na zápis i čítanie.</li>
<li>metódy <code>readXXX()</code> slúžia na načítavanie dát – k dispozícii je načítavanie primitívnych typov a reťazcov</li>
<li>metódy <code>writeXXX()</code> slúžia na zápis dát – k dispozícii je zápis primitívnych typov a reťazcov. Ak zápis presiahne koniec súboru, súbor sa predĺži.</li>
<li><code>long length()</code> vráti dĺžku súboru.</li>
<li><code>void setLength(long length)</code> nastaví dĺžku súboru. Súbor je tým možné predĺžiť alebo skrátiť.</li>

<li><p><code>void seek(long position)</code> sa umožňuje posúvať po súbore. Parametrom je pozícia od začiatku súboru, na ktorú sa má nastaviť kurzor, čiže pozícia, od ktorej bude prebiehať najbližšie čítanie alebo zápis.
Príkladom použitia je nasledovný kód:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">RandomAccessFile <span style="color:#5ed;font-weight:bold">raf</span> <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">null</span>;
<span style="color:#289;font-weight:bold">try</span> {
raf <span style="color:#333">=</span> <span style="color:#289;font-weight:bold">new</span> RandomAccessFile(<span style="background-color:#e0e0ff">&#34;binary.dat&#34;</span>, <span style="background-color:#e0e0ff">&#34;rw&#34;</span>);
raf.<span style="color:#007">writeChars</span>(<span style="background-color:#e0e0ff">&#34;a&#34;</span>); <span style="color:#666;font-style:italic">//char zaberá dva bajty
</span><span style="color:#666;font-style:italic"></span>raf.<span style="color:#007">writeByte</span>(128);  <span style="color:#666;font-style:italic">//jeden bajt
</span><span style="color:#666;font-style:italic"></span>raf.<span style="color:#007">seek</span>(0);         <span style="color:#666;font-style:italic">//posun na začiatok
</span><span style="color:#666;font-style:italic"></span><span style="color:#66f;font-weight:bold">char</span> <span style="color:#5ed;font-weight:bold">c</span> <span style="color:#333">=</span> raf.<span style="color:#007">readChar</span>(); <span style="color:#666;font-style:italic">//načíta znak (dva bajty)
</span><span style="color:#666;font-style:italic"></span>System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(c);   <span style="color:#666;font-style:italic">//vypíše znak
</span><span style="color:#666;font-style:italic"></span>System.<span style="color:#007">out</span>.<span style="color:#007">println</span>(raf.<span style="color:#007">getFilePointer</span>()); <span style="color:#666;font-style:italic">// sme na pozícii 2
</span><span style="color:#666;font-style:italic"></span>} <span style="color:#289;font-weight:bold">catch</span> (FileNotFoundException <span style="color:#5ed;font-weight:bold">e</span>) {
e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">catch</span> (IOException <span style="color:#5ed;font-weight:bold">e</span>) {
e.<span style="color:#007">printStackTrace</span>();
} <span style="color:#289;font-weight:bold">finally</span> {
<span style="color:#289;font-weight:bold">try</span> {
raf.<span style="color:#007">close</span>();
} <span style="color:#289;font-weight:bold">catch</span> (Exception <span style="color:#5ed;font-weight:bold">e</span>) {
<span style="color:#666;font-style:italic">//do nothing
</span><span style="color:#666;font-style:italic"></span>}
}</code></pre></div></li>
</ul>

<h1 id="literatúra-a-odkazy">Literatúra a odkazy</h1>

<ul>
<li><a href="http://www.digilife.be/quickreferences/PT/Introduction%20to%20Java%20IO.pdf">Introduction to Java IO</a> – tutoriál IBM</li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/package-summary.html">Balíček <code>java.io</code></a> – dokumentácia</li>
<li>Java Developer&rsquo;s Almanac. Recepty na riešenie častých úloh s použitím <a href="http://www.exampledepot.com/egs/java.io/pkg.html">balíčka <code>java.io</code></a></li>
</ul>

</main>

    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
    </footer>
  </body>
</html>

