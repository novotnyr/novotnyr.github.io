<!DOCTYPE html>
<html lang="en-us">
  <head>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>Použila listy s monádou a zažila šok! | robonovotny</title>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.3/styles/dracula.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.3/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.3/languages/go.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="https://novotnyr.github.io/asciidoctor.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="https://novotnyr.github.io/">~/robonovotny</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">Použila listy s monádou a zažila šok!</span></h1>

<h2 class="date">2021/09/25</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <blockquote>
<p>Odkedy používam zoznamy s monádou, môj život je omnoho lepší!</p>
</blockquote>
<p>Už včera sme videli, že škatule a objekty <code>Maybe</code> zlepšujú zápis alebo predchádzajú chybám s <code>null</code>! A to všetko vďaka návrhovému vzoru <strong>monáda</strong>.</p>
<p>Teraz je čas postúpiť ďalej: kým škatule a <em>môžbyť</em> obsahovali vec alebo „žiadnu vec“, ukážme si namonádovaný zoznam, ktorý obsahuje <strong>viac položiek!</strong></p>
<p>Monáda potrebuje:</p>
<ul>
<li>Dátový typ, ktorý obalí,</li>
<li>Spôsob, akým obalí veci daného typu,</li>
<li>Metódu, ktorá vybalí vnútro monády, použije naň <em>funkciu</em> a z nej získa novú zabalenú vec.</li>
</ul>
<h1 id="monadický-zoznam">Monadický zoznam!</h1>
<p>Vyrobme si teraz monadický zoznam prvkov a nazvime ho <strong>superzoznam</strong> <code>SuperList</code>, pretože bude omnoho lepší než klasický zoznam!</p>
<ul>
<li>obalíme ľubovoľný dátový typ <code>T</code> a pripravíme si:
<ul>
<li>konštruktor, ktorý vie prevziať kolekciu prvkov typu <code>T</code></li>
<li>pomocnú statickú metódu, ktorou vybudujeme superlist na základe viacerých prvkov</li>
</ul>
</li>
<li>pripravíme si zabaľovaco-vybaľovaco-spracovateľskú metódu, ale teraz sa nebude volať <code>then</code>, ale <code>bind</code> (bude to lepšie vyzerať).</li>
</ul>
<h2 id="metóda-bind">Metóda <code>bind</code></h2>
<p>Metóda <code>then</code>, teda <code>bind</code> bude vyzerať nasledovne:</p>
<ul>
<li>pripravíme si prázdny výsledný zoznam prvkov</li>
<li>nad každým prvkom z aktuálneho superzoznamu zavoláme funkciu, ktorá spočíta údaje a vráti nový superzoznam</li>
<li>z tohto nového superzoznamu vytiahneme vnútro &ndash; teda prvky a prehodíme ich do celkového výsledného zoznamu prvkov</li>
<li>na konci obalíme výsledný zoznam prvkov do superzoznamu a vrátime ho ako výsledok!</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">bind</span>(Function<span style="color:#f92672">&lt;</span>T, SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;&gt;</span> handler) {
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> newItems <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (T item : items) {
</span></span><span style="display:flex;"><span>        SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> partialSuperList <span style="color:#f92672">=</span> handler.<span style="color:#a6e22e">apply</span>(item);
</span></span><span style="display:flex;"><span>        newItems.<span style="color:#a6e22e">addAll</span>(partialSuperList.<span style="color:#a6e22e">getItems</span>());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SuperList<span style="color:#f92672">&lt;&gt;</span>(newItems);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="celý-kód">Celý kód</h2>
<p>Celý kód obsahuje už len tri veci:</p>
<ul>
<li>konštruktor, ktorým vytvoríme superzoznam na základe klasickej kolekcie</li>
<li>pomocná metóda na vytváranie superzoznamu z prvkov, čo sa hodí v testoch</li>
<li>a metóda, ktorou získame zo superzoznamu klasický zoznamu</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.github.novotnyr.monad.list;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Arrays;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Collection;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.List;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.function.Function;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuperList</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> List<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> items <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SuperList</span>(Collection<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> entries) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">items</span>.<span style="color:#a6e22e">addAll</span>(entries);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">bind</span>(Function<span style="color:#f92672">&lt;</span>T, SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;&gt;</span> handler) {
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> newItems <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>(); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (T item : items) {
</span></span><span style="display:flex;"><span>            SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> partialSuperList <span style="color:#f92672">=</span> handler.<span style="color:#a6e22e">apply</span>(item);
</span></span><span style="display:flex;"><span>            newItems.<span style="color:#a6e22e">addAll</span>(partialSuperList.<span style="color:#a6e22e">getItems</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SuperList<span style="color:#f92672">&lt;&gt;</span>(newItems);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> SuperList<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">listOf</span>(T... items) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SuperList<span style="color:#f92672">&lt;&gt;</span>(Arrays.<span style="color:#a6e22e">asList</span>(items));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getItems</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">items</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unit test bude vytvorí zoznam troch čísiel, vynásobí ich dvoma a zistí, či to zbehlo v poriadli:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.github.novotnyr.monad.list;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.junit.jupiter.api.Assertions;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.junit.jupiter.api.Test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Arrays;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.List;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import static</span> com.github.novotnyr.monad.list.SuperList.listOf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuperListTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testMultiplication</span>() {
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> doubles <span style="color:#f92672">=</span> listOf(1, 2, 3)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">bind</span>(n <span style="color:#f92672">-&gt;</span> listOf(n <span style="color:#f92672">*</span> 2))
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">getItems</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Assertions.<span style="color:#a6e22e">assertEquals</span>(Arrays.<span style="color:#a6e22e">asList</span>(2, 4, 6), doubles);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Keďže sme si umne pripravili statickú metódu <code>listOf()</code>, s použitím statického importu máme celkom pekný zápis!</p>
<h1 id="pravá-zábava-výpočty-nad-funkciami-s-viacerými-výsledkami">Pravá zábava: výpočty nad funkciami s viacerými výsledkami</h1>
<p>Toto je samozrejme v poriadku, ale pravá zábava nastáva vtedy, ak máme výpočty, ktoré môžu vracať viac hodnôt <strong>naraz</strong>!</p>
<p>Vymyslime si metódu, ktorá pre číslo <em>n</em> vráti jeho susedov: teda číslo o jedna menšie, samotné číslo a číslo o 1 väčšie.</p>
<p>Inak povedané, vstupom metódy je číslo a výsledkom je trojica čísiel.
Keďže máme superzoznam, neváhajme ho použiť!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.github.novotnyr.monad.list;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import static</span> com.github.novotnyr.monad.list.SuperList.listOf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Utils</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> SuperList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">neighbours</span>(<span style="color:#66d9ef">int</span> number) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> listOf(number <span style="color:#f92672">-</span> 1, number, number <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Test potom vyzerá nasledovne:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testNeighbours</span>() {
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> neighbours <span style="color:#f92672">=</span> listOf(1, 2, 3)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">bind</span>(Utils::neighbours)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">getItems</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> expected <span style="color:#f92672">=</span> Arrays.<span style="color:#a6e22e">asList</span>(0, 1, 2, 1, 2, 3, 2, 3, 4);
</span></span><span style="display:flex;"><span>    Assertions.<span style="color:#a6e22e">assertEquals</span>(expected, neighbours);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Vytvorili sme superzoznam troch čísiel, aplikovali naň funkciu <code>neighbours</code> a výsledkom je .. spľasnutý zoznam deviatich čísiel!</p>
<p>Presnešie povedané, postupne prechádzame zoznam troch čísiel, na každé z nich použijeme <code>neighbours</code> a výsledné čiastkové superzoznamy zlúčime dohromady do jedného zoznamu.</p>
<p>Postupne to vyzerá nasledovne</p>
<pre tabindex="0"><code>1 -&gt; [0, 1, 2]
2 -&gt; [1, 2, 3]
3 -&gt; [2, 3, 4]
</code></pre><p>Máme teda zoznam troch zoznamov:</p>
<pre tabindex="0"><code>[[0, 1, 2], [1, 2, 3], [2, 3, 4]]
</code></pre><p>Funkcia <code>bind</code> zoberie tri čiastkové superzoznamy a zlepí ich dohromady do jedného veľkého superzoznamu:</p>
<h1 id="susedia-a-duplikácie">Susedia a duplikácie!</h1>
<p>Môžeme si urobiť aj iný test, kde zistíme susedov a každého z nich zduplikujeme!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testNeighboursAndDuplicate</span>() {
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> neighbours <span style="color:#f92672">=</span> listOf(7)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">bind</span>(Utils::neighbours)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">bind</span>(n <span style="color:#f92672">-&gt;</span> listOf(n <span style="color:#f92672">*</span> 2))
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">getItems</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> expected <span style="color:#f92672">=</span> Arrays.<span style="color:#a6e22e">asList</span>(12, 14, 16);
</span></span><span style="display:flex;"><span>    Assertions.<span style="color:#a6e22e">assertEquals</span>(expected, neighbours);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Z čísla 7 vzniknú susedia 6, 7 a 8, a keď ich zduplikujeme, očakávame 12, 14 a 16!</p>
<h1 id="jednoduchší-bind---skratka-pre-prevod-prvku-na-prvok">Jednoduchší bind - skratka pre prevod prvku na prvok</h1>
<p>Metóda <code>bind</code> očakávala funkciu, ktorá vráti superzoznam, teda monadický zoznam.
Mnohokrát sme však leniví a vieme, že každý prvok zoznamu budeme premieňať na iný prvok zoznamu.</p>
<p>Nebolo by skvelé niečo takéto?</p>
<pre><code>List&lt;Integer&gt; doubles = listOf(1, 2, 3)
        .bind(n -&gt; n * 2)
        .getItems();
</code></pre>
<p>Určite áno!</p>
<p>Našťastie, ak skombinujeme <code>bind</code> a obaľovaciu funkciu <code>listOf</code>, vieme si zjednodušiť život.</p>
<p>Dôležité je, že funkcia v parametri už nevracia superzoznam <code>SuperList&lt;R&gt;</code>, ale len bežný jednoduchý prvok <code>R</code>.</p>
<p>Iniciálny kód:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> SuperList<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">map</span>(Function<span style="color:#f92672">&lt;</span>T, R<span style="color:#f92672">&gt;</span> mapper) {
</span></span><span style="display:flex;"><span>    List<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> newItems <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (T item : items) {
</span></span><span style="display:flex;"><span>        R partialItem <span style="color:#f92672">=</span> mapper.<span style="color:#a6e22e">apply</span>(item);
</span></span><span style="display:flex;"><span>        newItems.<span style="color:#a6e22e">add</span>(partialItem);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SuperList<span style="color:#f92672">&lt;&gt;</span>(newItems);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Otestujeme to so zjednodušeným zápisom:</p>
<pre tabindex="0"><code>@Test
public void testMultiplicationWithMap() {
    List&lt;Integer&gt; doubles = listOf(1, 2, 3)
            .map(n -&gt; n * 2)
            .getItems();

    Assertions.assertEquals(Arrays.asList(2, 4, 6), doubles);
}
</code></pre><p>Namiesto zápisu <code>bind(n -&gt; listOf(n * 2)</code> už vraciame len jednoduchý dvojnásobok. Funkcia <code>map</code> sa postará o odbalenie a zabalenie do monádového superzoznamu.</p>
<p>Ak by sme chceli skombinovať <code>bind</code> a <code>listOf</code> a máme odvahu skladať funkcie, spravme to:</p>
<pre tabindex="0"><code>public &lt;R&gt; SuperList&lt;R&gt; map(Function&lt;T, R&gt; mapper) {
    Function&lt;T, SuperList&lt;R&gt;&gt; handler = mapper.andThen(SuperList::listOf);
    return bind(handler);
}
</code></pre><h1 id="čo-sme-ukázali">Čo sme ukázali?</h1>
<p>Náš superzoznam je tretí príklad monády, ktorý ukazuje, že stačí definovať triedu obaľujúcu typ, pridať pár konštruktorov, a metódu <code>then</code>, resp <code>bind</code> a vieme robiť kúzelné veci!</p>
<p>Pekné prekvapenie je, že v Jave už superzoznam existuje: stačí na <code>java.util.List</code> zavolať metódu <code>stream()</code> a získať prúd <code>java.util.stream.Stream!</code></p>
<ul>
<li>metóda <code>map</code> je rovnaká ako naša metóda <code>map</code></li>
<li>a metóda <code>flatMap</code> je rovnaká ako naša metóda <code>bind</code>.</li>
</ul>
<p>Názov <code>flatMap</code> znamená, že prvok premeníme &ndash; namapujeme &ndash; na iný prvok zoznamu a ak by náhodou tento výsledný prvok predstavoval zoznam, tak ho odbalíme („spľaštíme“) a jeho vnorené prvky vložíme do výsledku bez obalu.</p>
<pre><code>@Test
void testStream() {
    List&lt;Integer&gt; neighbours = Stream.of(1, 2, 3)
            .flatMap(n -&gt; Stream.of(n - 1, n, n + 1))
            .collect(Collectors.toList());

    List&lt;Integer&gt; expected = Arrays.asList(0, 1, 2, 1, 2, 3, 2, 3, 4);
    Assertions.assertEquals(expected, neighbours);
}
</code></pre>
<p>To je dôkaz, že od istej chvíle všetko bude vyzerať ako monáda!</p>

    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
    </footer>
  </body>
</html>

