<!DOCTYPE html>
<html lang="en-us">
  <head>

    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/site.webmanifest">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>Recepty pre gorutiny a kanály | robonovotny</title>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="https://novotnyr.github.io/asciidoctor.css">
    <header>

  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="https://novotnyr.github.io/">~/robonovotny</a>
      </li>
      

      

    </ul>
  </nav>
</header>

  </head>

  <body>
    <br/>

<div class="article-meta">
<h1><span class="title">Recepty pre gorutiny a kanály</span></h1>

<h2 class="date">2023/01/07</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>


<div class="content-wrapper">
  <main>
    <div class="sect1">
<h2 id="_čo_je_gorutina">Čo je gorutina?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gorutina je ľahučké vlákenko na vykonávanie paralelných úloh v Go.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_paralelné_gorutiny">Paralelné gorutiny</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vypisujme paralelne čísla od 1 po 10.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">package main

import (
	&#34;log&#34;
	&#34;time&#34;
)

func main() {
	go print(&#34;goroutine&#34;) <i class="conum" data-value="1"></i><b>(1)</b>
	print(&#34;main&#34;) <i class="conum" data-value="2"></i><b>(2)</b>
}

func print(c string) {
	for i := 0; i &lt; 10; i++ {
		log.Printf(&#34;%10s %d\n&#34;, c, i)
		time.Sleep(1 * time.Second) <i class="conum" data-value="3"></i><b>(3)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Spustíme funkciu ako gorutinu paralelne s behom funkcie <code>main</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Funkcia <code>main</code> beží v hlavnej gorutine.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>V každom kole výpisu zaspíme na sekundu.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Výsledkom bude paralelný výpis čísiel, napríklad takýto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2023/01/08 11:30:39       main 0
2023/01/08 11:30:39  goroutine 0
2023/01/08 11:30:40       main 1
2023/01/08 11:30:40  goroutine 1
2023/01/08 11:30:41  goroutine 2
2023/01/08 11:30:41       main 2
2023/01/08 11:30:42       main 3
2023/01/08 11:30:42  goroutine 3
2023/01/08 11:30:43  goroutine 4
2023/01/08 11:30:43       main 4</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Výpisy idú bok po boku.</p>
</li>
<li>
<p>Niekedy je poradie vymenené, pretože závisí od poradia vykonávania, ktoré je prakticky nepredvídateľné.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nečakáme">Nečakáme!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Skúsme spustiť len samotnú gorutinu.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">package main

import (
	&#34;log&#34;
	&#34;time&#34;
)

func print(c string) {
	for i := 0; i &lt; 10; i++ {
		log.Printf(&#34;%10s %d\n&#34;, c, i)
		time.Sleep(1 * time.Second)
	}
}

func main() {
	go print(&#34;goroutine&#34;) <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hlavná gorutina len spustí funkciu <code>print</code> ako gorutinu.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ak to však spustíme, neuvidíme nič.</p>
</div>
<div class="paragraph">
<p>Hlavná gorutina vo funkcii <code>main()</code> je veľmi rýchla a nebude čakať na dobehnutie gorutiny s funkciou <code>print</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_čakanie_pri_kanáli">Čakanie pri kanáli</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ak chceme počkať na dokončenie jednej gorutiny, použime kanál.</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Kanál (<em>channel</em>) je rúra, ktorou tečú typované dáta.</p>
</div>
<div class="paragraph">
<p>Do jedného konca lejeme dáta — zapisujeme — z druhého konca sa dáta lejú von — čítame ich.</p>
</div>
<div class="paragraph">
<p>Kanály umožňujú bezpečnú komunikáciu medzi gorutinami bez nutnosti riešiť konkurentné problémy s prístupom k spoločným dátam.</p>
</div>
<div class="paragraph">
<p>Ten, kto zapisuje do kanála, sa často nazýva <em>producent</em>, a ten, kto číta, je <em>konzument</em>.
Do jedného kanála môže zapisovať viacero producentov a čítať môže rovnako viacero konzumentov.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Kanál vytvárame zabudovanou funkciou <code>make</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">done := make(chan bool) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Vytvoríme kanál, ktorým tečú <em>booleany</em>.
Tento kanál je <strong>nebufferovaný</strong>.</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Nebufferovaný kanál (<em>unbuffered channel</em>) slúži na synchrónnu komunikáciu medzi producentom a konzumentom.</p>
</div>
<div class="paragraph">
<p>Producent <em>čaká</em> (<em>blokuje</em>) pri zápise hodnoty dovtedy, kým si ju konzument neprečíta.</p>
</div>
<div class="paragraph">
<p>To platí aj naopak — konzument čaká s čítaním dovtedy, kým producent nezapíše hodnotu.</p>
</div>
<div class="paragraph">
<p>Ako hovorí dokumentácia: „komunikácia uspeje len vtedy, ak odosielateľ a prijímateľ sú pripravení“.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ukážme si použitie kanála s čakaním na výsledok.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	&#34;log&#34;
	&#34;time&#34;
)

func main() {
	done := make(chan bool) <i class="conum" data-value="1"></i><b>(1)</b>
	go print(&#34;goroutine&#34;, done) <i class="conum" data-value="2"></i><b>(2)</b>
	isDone := &lt;-done <i class="conum" data-value="5"></i><b>(5)</b>
	log.Printf(&#34;main completed: %v&#34;, isDone) <i class="conum" data-value="6"></i><b>(6)</b>
}

func print(c string, done chan bool) { <i class="conum" data-value="3"></i><b>(3)</b>
	for i := 0; i &lt; 10; i++ {
		log.Printf(&#34;%10s %d\n&#34;, c, i)
		time.Sleep(1 * time.Second)
	}
	done &lt;- true <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Vytvoríme nebufferovaný kanál pre booleovské hodnoty.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Kanál pošleme ako argument do funkcie <code>print</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Funkcia má samostatný parameter typu <code>chan bool</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Po skončení výpisu indikujeme koniec vykonávania funkcie zápisom do kanála.
Čítame „do kanála <code>done</code> zapíšeme hodnotu <code>true</code>“.
Šípka ukazuje tok údajov!</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>V hlavnej gorutine čítame z kanála.
Čítame „do premennej <code>isDone</code> načítame hodnotu z kanála <code>done</code>“.
Šípka opäť ukazuje tok údajov!
<div class="paragraph">
<p>Na tomto mieste zároveň blokujeme — čakáme, kým do kanála niekto nezapíše hodnotu a to sa stane až na konci funkcie <code>print</code>.</p>
</div></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dôležité veci pri kanáloch:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>make</code> vytvára kanál</p>
</li>
<li>
<p>kanál má typ <code>chan &lt;dátovýTyp&gt;</code></p>
</li>
<li>
<p><code>← done</code> číta z kanála jednu hodnotu</p>
</li>
<li>
<p><code>done ← true</code> zapisuje do kanála jednu hodnotu</p>
</li>
<li>
<p>kanály posielame do funkcie priamo — nepoužívame pointre!</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="_upratovanie">Upratovanie</h3>
<div class="paragraph">
<p>Preleštime si ešte kód:</p>
</div>
<div class="paragraph">
<p>V tomto prípade len čakáme na dobehnutie korutiny a skutočná hodnota v kanáli nás nezaujíma.</p>
</div>
<div class="paragraph">
<p>Čítanie tak môžeme zjednodušiť:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func main() {
	done := make(chan bool)
	go print(&#34;goroutine&#34;, done)
	&lt;-done <i class="conum" data-value="1"></i><b>(1)</b>
	log.Printf(&#34;main completed&#34;)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Čítame nejakú hodnotu, ktorej výsledok nás nezaujíma.
Dôležité je, že blokujeme hlavnú gorutinu — čakáme na producenta.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ak používame kanál v parametri funkcie, oplatí sa určiť, či z kanála čítame alebo zapisujeme.</p>
</div>
<div class="paragraph">
<p>Nasledovný parameter hovorí, že funkcia do kanála len zapisuje:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>done chan&lt;- bool</code></pre>
</div>
</div>
<div class="paragraph">
<p>Šípka opäť ukazuje smer toku údajov!</p>
</div>
<div class="paragraph">
<p>V kóde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func print(c string, done chan&lt;- bool) {
    //... zvyšok
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Šípky sú hlavne dokumentačné, aby používateľ funkcie vedel, ako sa s kanálom pracuje.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done chan← bool</code>: funkcia len zapisuje do kanála booleovské hodnoty.</p>
</li>
<li>
<p><code>jobs ←chan string</code>: funkcia len číta z kanála reťazce</p>
</li>
<li>
<p><code>signals chan int</code>: funkcia mieni čítať aj zapisovať čísla.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dobré vývojové prostredie vie upozorniť na prípad, keď parameter a jeho tok údajov nezodpovedá realite v kóde.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_čakanie_na_výsledok">Čakanie na výsledok</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Funkcia spúšťané v gorutine nemôže vracať výsledok cez <code>return</code>.
To by popieralo jej zmysel, pretože volanie funkcie s návratovou hodnotou v bežnom kóde doslova čaká na výsledok, a pri gorutinách je dôležité paralelný beh bez čakania.</p>
</div>
<div class="paragraph">
<p>Výsledky gorutín patria do výstupného kanála!</p>
</div>
<div class="paragraph">
<p>Ukážme si slimačí výpočet faktoriálu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func factorial(n int, result chan&lt;- int) { <i class="conum" data-value="1"></i><b>(1)</b>
	fac := 1
	for i := 1; i &lt;= n; i++ {
		fac = fac * i
		time.Sleep(1 * time.Second)
		log.Printf(&#34;%d! = %d&#34;, i, fac)
	}
	result &lt;- fac <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Výsledok je číslo, patrí do kanála čísiel, ktorý príde ako argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Hotový výsledok zapíšeme do kanála.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Číslo prečítame z kanála podobne ako pri bežnom čakaní.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func main() {
	result := make(chan int) <i class="conum" data-value="1"></i><b>(1)</b>
	go factorial(5, result)
	log.Printf(&#34;Result: %d&#34;, &lt;-result) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Vytvoríme kanál čísiel <code>int</code> pre výsledky.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Čakáme — blokujeme hlavnú gorutinu — kým nepríde výsledok.</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_priebežné_výsledky">Priebežné výsledky</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Do kanála môžeme zapisovať viacero hodnôt.</p>
</div>
<div class="paragraph">
<p>Ak máme nebufferovaný kanál, zápis každej hodnoty vždy čaká na čítanie od konzumenta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func factorial(n int, result chan&lt;- int) {
	fac := 1
	for i := 1; i &lt;= n; i++ {
		fac = fac * i
		time.Sleep(1 * time.Second)
		log.Printf(&#34;Producing %d! = %d&#34;, i, fac)
		result &lt;- fac <i class="conum" data-value="1"></i><b>(1)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Priebežne zapisujeme výsledky do kanála.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func main() {
	result := make(chan int)
	n := 5
	go factorial(n, result)
	for i := 1; i &lt;= n; i++ { <i class="conum" data-value="1"></i><b>(1)</b>
		log.Printf(&#34;Consuming %d! = %d&#34;, i, &lt;-result) <i class="conum" data-value="2"></i><b>(2)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Budeme čítať toľko hodnôt, koľko medzivýsledkov očakávame.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Vždy načítame čiastočný výsledok.
Posledný výsledok je finálny.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Keďže máme nebufferovaný kanál, každý zápis čaká na čítanie, čiže každé produkovanie čaká na konzum — a teda vidíme na striedačku zápis-čítanie, zápis-čítanie, zápis-čítanie.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">2023/01/11 10:15:21 Producing 1! = 1
2023/01/11 10:15:21 Consuming 1! = 1
2023/01/11 10:15:22 Producing 2! = 2
2023/01/11 10:15:22 Consuming 2! = 2
2023/01/11 10:15:23 Producing 3! = 6
2023/01/11 10:15:23 Consuming 3! = 6
2023/01/11 10:15:24 Producing 4! = 24
2023/01/11 10:15:24 Consuming 4! = 24
2023/01/11 10:15:25 Producing 5! = 120
2023/01/11 10:15:25 Consuming 5! = 120</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_priebežné_výsledky_s_uzavretím_kanála">Priebežné výsledky s uzavretím kanála</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ak čítame z nebufferovaného kanála, kde sa objavuje viacero hodnôt, musíme vedieť, kedy skončiť. V opačnom prípade sa zahrávame s deadlockom.</p>
</div>
<div class="paragraph">
<p>Ak by sme z kanála omylom načítali postupne viac hodnôt než zapísal konzument (napríklad 6 výsledkov pre faktoriál 5), uvidíme <strong>deadlock</strong> — vzájomné vyblokovanie producenta a konzumenta.
V tomto prípade by konzument márne čakal na producenta, ktorý už nikdy nič nezapíše.</p>
</div>
<div class="paragraph">
<p>Koniec čítania vieme realizovať:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>buď počítadlom výsledkov</p>
</li>
<li>
<p>alebo explicitným uzavretím kanála.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Počítanie výsledkov sme videli v kanáli. Ak gorutina vyráta faktoriál 3, očakávame tri výsledky a tri iterácie pri čítaní.</p>
</div>
<div class="paragraph">
<p>Druhá možnosť je explicitné uzavretie kanála.
Na to slúži zabudovaná funkcia <code>close</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Kanál má uzatvárať producent, nikdy nie konzument! Filozoficky to zodpovedá „koncu súboru“ (<em>end-of-file</em>).
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func factorial(n int, result chan&lt;- int) {
	fac := 1
	for i := 1; i &lt;= n; i++ {
		fac = fac * i
		time.Sleep(1 * time.Second)
		log.Printf(&#34;Producing %d! = %d&#34;, i, fac)
		result &lt;- fac
	}
	close(result) <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Po vyprodukovaní všetkých výsledkov producent uzavrie kanál.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ak vieme, že kanál bude uzatvorený, môžeme položky z kanála konzumovať kombináciou cyklu <code>for</code> a operátora <code>range</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>range</code> postupne číta prvky z kanála dovtedy, kým sa kanál neuzavrie.
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func main() {
	result := make(chan int)
	n := 5
	go factorial(n, result)
	for fac := range result { <i class="conum" data-value="1"></i><b>(1)</b>
		log.Printf(&#34;Consuming result %d&#34;, fac) <i class="conum" data-value="2"></i><b>(2)</b>
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Čítame z kanála a každý prvok priradíme do premennej <code>fac</code>.
V každej iterácii akoby sme vykonali <code>fac := ←result</code>, čo opakujeme dovtedy, kým sa kanál nezavrie.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Keďže máme nebufferovaný kanál, čítanie vždy čaká na zápis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>2023/01/11 10:29:41 Producing 1! = 1
2023/01/11 10:29:41 Consuming result 1
2023/01/11 10:29:42 Producing 2! = 2
2023/01/11 10:29:42 Consuming result 2
2023/01/11 10:29:43 Producing 3! = 6
2023/01/11 10:29:43 Consuming result 6
2023/01/11 10:29:44 Producing 4! = 24
2023/01/11 10:29:44 Consuming result 24
2023/01/11 10:29:45 Producing 5! = 120
2023/01/11 10:29:45 Consuming result 120</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rýchly_producent_pomalý_konzument">Rýchly producent, pomalý konzument</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Doteraz sme mali pomalého producenta a rýchleho konzumenta na nebufferovanom kanáli?</p>
</div>
<div class="paragraph">
<p>Čo ak to bude naopak?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func factorial(n int, result chan&lt;- int) {
	fac := 1
	for i := 1; i &lt;= n; i++ {
		fac = fac * i
		log.Printf(&#34;Producing %d! = %d&#34;, i, fac)
		result &lt;- fac <i class="conum" data-value="1"></i><b>(1)</b>
	}
	close(result)
}

func main() {
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)

	n := 5
	result := make(chan int)
	go factorial(n, result)
	for fac := range result {
		time.Sleep(1 * time.Second) <i class="conum" data-value="2"></i><b>(2)</b>
		log.Printf(&#34;Consuming result %d&#34;, fac)
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Producent chrlí medzivýsledky tak rýchlo, ako to ide.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Konzument je pomalý, trvá mu sekundu zožuť výsledok.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ako bude vyzerať beh?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>2023/01/11 12:01:16.530831 Producing 1! = 1
2023/01/11 12:01:16.530956 Producing 2! = 2
2023/01/11 12:01:17.532070 Consumed result 1
2023/01/11 12:01:17.532102 Producing 3! = 6
2023/01/11 12:01:18.534279 Consumed result 2
2023/01/11 12:01:18.534329 Producing 4! = 24
2023/01/11 12:01:19.534741 Consumed result 6
2023/01/11 12:01:19.535096 Producing 5! = 120
2023/01/11 12:01:20.536281 Consumed result 24
2023/01/11 12:01:21.538732 Consumed result 120</code></pre>
</div>
</div>
<div class="paragraph">
<p>Riadky sú nateraz poprehadzované, ale to má dôvod.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Producent vyprodukuje výsledok <code>1</code> a čaká na konzumenta.</p>
</li>
<li>
<p>Prakticky okamžite sa spustí čítanie kanála cez operátor <code>range</code>, ale spracovanie načítaného prvku okamžite zaspí na sekundu. Tak či onak, prvok opustil kanál a producent môže produkovať ďalej výsledok pre <code>2!</code>.</p>
</li>
<li>
<p>Ihneď na to sa vyprodukuje výsledok pre faktoriál 2 a čaká sa konzumenta v druhej iterácii.</p>
</li>
<li>
<p>Konzument však paralelne sekundu spí a keď sa zobudí, skonzumuje výsledok <code>1</code>.</p>
</li>
<li>
<p>To odblokuje producenta, ktorý môže vyrátať <code>3!</code> a zapísať do do kanála.</p>
</li>
<li>
<p>Paralelne ubehne sekunda, keď konzument žul výsledok pre <code>2! = 1</code>.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rýchly_producent_a_rýchly_konzument">Rýchly producent a rýchly konzument</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Čo ak je producent aj konzument taký rýchly, ako to ide?</p>
</div>
<div class="paragraph">
<p>Odstráňme všetky spánky cez <code>sleep</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>2023/01/11 12:11:26.616269 Producing 1! = 1
2023/01/11 12:11:26.616370 Producing 2! = 2
2023/01/11 12:11:26.616372 Consumed result 1
2023/01/11 12:11:26.616373 Consumed result 2
2023/01/11 12:11:26.616374 Producing 3! = 6
2023/01/11 12:11:26.616375 Producing 4! = 24
2023/01/11 12:11:26.616376 Consumed result 6
2023/01/11 12:11:26.616377 Consumed result 24
2023/01/11 12:11:26.616378 Producing 5! = 120
2023/01/11 12:11:26.616382 Consumed result 120</code></pre>
</div>
</div>
<div class="paragraph">
<p>Filozofia je úplne rovnaká, producent paralelne produkuje hodnoty ale vždy čaká na konzumenta a naopak.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sumár">Sumár</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Zhrňme si veci:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>nebufferovaný kanál vytvárame cez <code>make</code></p>
</li>
<li>
<p>zapisujeme šípkou <code>←</code> za kanálom</p>
</li>
<li>
<p>čítame šípkou pred kanálom</p>
</li>
<li>
<p>pri nebufferovanom kanáli zápis čaká na čítanie a čítanie čaká na zápis hodnoty</p>
</li>
<li>
<p>kanál odovzdávame do funkcií priamo — nie cez pointer</p>
</li>
<li>
<p>kanál uzatvára producent cez <code>close</code></p>
</li>
<li>
<p><code>range</code> a <code>for</code> číta z kanála</p>
</li>
</ul>
</div>
</div>
</div>

    <a href="/"> >> Home</a>
  </main>
</div>
    <footer>
      
<script>
(function() {
  function center_el(tagName) {
    var tags = document.getElementsByTagName(tagName), i, tag;
    for (i = 0; i < tags.length; i++) {
      tag = tags[i];
      var parent = tag.parentElement;
      
      if (parent.childNodes.length === 1) {
        
        if (parent.nodeName === 'A') {
          parent = parent.parentElement;
          if (parent.childNodes.length != 1) continue;
        }
        if (parent.nodeName === 'P') parent.style.textAlign = 'center';
      }
    }
  }
  var tagNames = ['img', 'embed', 'object'];
  for (var i = 0; i < tagNames.length; i++) {
    center_el(tagNames[i]);
  }
})();
</script>

      
    </footer>
  </body>
</html>

